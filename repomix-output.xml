This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
cmd/
  api/
    main.go
  migrate/
    main.go
  worker/
    main.go
internal/
  adapters/
    handler/
      http/
        dto/
          account_response.go
          create_fixed_savings_request.go
          create_user_request.go
          login_user_request.go
          update_profile_request.go
          user_response.go
          validator.go
        account_handler.go
        auth.go
        jwt.go
        options.go
        server.go
        user_handler.go
    repository/
      postgres/
        account_repository.go
        errors.go
        interest_history_repository.go
        postgrestore.go
        profile_repository.go
        schemas.go
        transaction_repository.go
        user_repository.go
  application/
    account/
      account_service_test.go
      account_service.go
      errors.go
    user/
      user_service_test.go
      user_service.go
  config/
    config.go
  domain/
    account/
      account.go
    interest_history/
      interest_history.go
    transaction/
      transaction.go
    user/
      profile.go
      user.go
  ports/
    account_repository.go
    account_service.go
    interest_history_repository.go
    profile_repository.go
    transaction_repository.go
    user_repository.go
    user_service.go
migrations/
  20250924034000_create_users_table.sql
  20250924103000_create_accounts_table.sql
  20250925103100_create_transactions_table.sql
  20250926034100_create_profiles_table.sql
  20250926034200_create_bank_links_table.sql
  20250926034300_create_interest_history_table.sql
mocks/
  ports_mocks.go
pkg/
  logger/
    logger.go
  sentry/
    sentry.go
  uuidv7.go
.air.toml
.gitignore
.mockery.yml
.rooignore
docker-compose.yml
go.mod
Makefile
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="cmd/worker/main.go">
package main

import (
	"context"
	"log"

	"e-wallet/internal/adapters/repository/postgres"
	"e-wallet/internal/application/account"
	"e-wallet/internal/config"
	"e-wallet/pkg/logger"

	sentrygo "github.com/getsentry/sentry-go"
)

func main() {
	applog, err := logger.NewAppLogger()
	if err != nil {
		log.Fatalf("cannot load config: %v\n", err)
	}

	cfg, err := config.LoadConfig()
	if err != nil {
		applog.Fatal(err)
	}

	err = sentrygo.Init(sentrygo.ClientOptions{
		Dsn:              cfg.SentryDSN,
		Environment:      cfg.AppEnv,
		AttachStacktrace: true,
	})
	if err != nil {
		applog.Fatalf("cannot init sentry: %v", err)
	}

	db, err := postgres.NewConnection(postgres.ParseFromConfig(cfg))
	if err != nil {
		applog.Fatal(err)
	}

	repo := postgres.NewUserRepository(db)
	profileRepo := postgres.NewProfileRepository(db)
	accountRepo := postgres.NewAccountRepository(db)
	txRepo := postgres.NewTransactionRepository(db)
	ihRepo := postgres.NewInterestHistoryRepository(db)
	accountService := account.NewAccountService(accountRepo, repo, profileRepo, txRepo, ihRepo)

	// Run interest calculation
	if err := accountService.CalculateDailyInterest(context.Background()); err != nil {
		applog.Fatal(err)
	}

	applog.Info("Interest calculation completed successfully")
}
</file>

<file path="internal/adapters/handler/http/dto/create_fixed_savings_request.go">
package dto

type CreateFixedSavingsRequest struct {
	TermMonths int `json:"term_months" validate:"required,oneof=1 3 6 8 12"`
}
</file>

<file path="internal/adapters/handler/http/dto/login_user_request.go">
package dto

type LoginUserRequest struct {
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required"`
}
</file>

<file path="internal/adapters/handler/http/dto/update_profile_request.go">
package dto

type UpdateProfileRequest struct {
	Username    string `json:"username" validate:"required"`
	DisplayName string `json:"display_name"`
	AvatarURL   string `json:"avatar_url"`
	PhoneNumber string `json:"phone_number"`
	NationalID  string `json:"national_id"`
	BirthYear   int    `json:"birth_year"`
	Gender      string `json:"gender"`
	Team        string `json:"team" validate:"team"`
}
</file>

<file path="internal/adapters/repository/postgres/errors.go">
package postgres

import "errors"

var (
	ErrUserNotFound = errors.New("user not found")
	ErrProfileNotFound = errors.New("profile not found")
	ErrAccountNotFound = errors.New("account not found")
)
</file>

<file path="internal/adapters/repository/postgres/interest_history_repository.go">
package postgres

import (
	"context"
	"e-wallet/internal/domain/interest_history"
	"e-wallet/internal/ports"
	"time"

	"gorm.io/gorm"
)

const (
	InterestHistoryTableName = "interest_history"
)

type interestHistoryRepository struct {
	db *gorm.DB
}

func NewInterestHistoryRepository(db *gorm.DB) ports.InterestHistoryRepository {
	return &interestHistoryRepository{db: db}
}

func (r *interestHistoryRepository) Create(ctx context.Context, ih *interest_history.InterestHistory) (*interest_history.InterestHistory, error) {
	schema := InterestHistory{
		ID:             ih.ID,
		AccountID:      ih.AccountID,
		Date:           ih.Date,
		InterestAmount: ih.InterestAmount,
	}

	if err := r.db.WithContext(ctx).Table(InterestHistoryTableName).Create(&schema).Error; err != nil {
		return nil, err
	}

	return schema.ToDomain(), nil
}

type InterestHistory struct {
	ID             string
	AccountID      string
	Date           time.Time
	InterestAmount float64
	CreatedAt      time.Time `gorm:"autoCreateTime"`
}

func (i *InterestHistory) ToDomain() *interest_history.InterestHistory {
	return &interest_history.InterestHistory{
		ID:             i.ID,
		AccountID:      i.AccountID,
		Date:           i.Date,
		InterestAmount: i.InterestAmount,
		CreatedAt:      i.CreatedAt,
	}
}
</file>

<file path="internal/adapters/repository/postgres/transaction_repository.go">
package postgres

import (
	"context"
	"e-wallet/internal/domain/transaction"
	"e-wallet/internal/ports"
	"time"

	"gorm.io/gorm"
)

const (
	TransactionsTableName = "transactions"
)

type transactionRepository struct {
	db *gorm.DB
}

func NewTransactionRepository(db *gorm.DB) ports.TransactionRepository {
	return &transactionRepository{db: db}
}

func (r *transactionRepository) Create(ctx context.Context, tx *transaction.Transaction) (*transaction.Transaction, error) {
	schema := Transaction{
		ID:               tx.ID,
		AccountID:        tx.AccountID,
		TransactionType:  tx.TransactionType,
		Amount:           tx.Amount,
		Status:           tx.Status,
		BalanceAfter:     tx.BalanceAfter,
		RelatedAccountID: tx.RelatedAccountID,
	}

	if err := r.db.WithContext(ctx).Table(TransactionsTableName).Create(&schema).Error; err != nil {
		return nil, err
	}

	return schema.ToDomain(), nil
}

type Transaction struct {
	ID               string
	AccountID        string
	TransactionType  string
	Amount           float64
	Status           string
	BalanceAfter     float64
	RelatedAccountID *string
	CreatedAt        time.Time `gorm:"autoCreateTime"`
}

func (t *Transaction) ToDomain() *transaction.Transaction {
	return &transaction.Transaction{
		ID:               t.ID,
		AccountID:        t.AccountID,
		TransactionType:  t.TransactionType,
		Amount:           t.Amount,
		Status:           t.Status,
		BalanceAfter:     t.BalanceAfter,
		RelatedAccountID: t.RelatedAccountID,
		CreatedAt:        t.CreatedAt,
	}
}
</file>

<file path="internal/application/user/user_service_test.go">
package user

import (
	"context"
	"errors"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"golang.org/x/crypto/bcrypt"

	"e-wallet/internal/domain/user"
	"e-wallet/mocks"
)

// Helper function to hash password for tests
func hashPassword(password string) string {
	hashed, _ := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	return string(hashed)
}

func TestUserService_CreateUser(t *testing.T) {
	tests := []struct {
		name          string
		request       *user.CreateUserRequest
		mockSetup     func(*mocks.MockUserRepository, *mocks.MockProfileRepository)
		expectedUser  *user.User
		expectedError error
	}{
		{
			name: "success - create user",
			request: &user.CreateUserRequest{
				Username: "testuser",
				Email:    "test@example.com",
				Password: "password123",
			},
			mockSetup: func(userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				userRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(u *user.User) bool {
					return u.Username == "testuser" && u.Email == "test@example.com" && len(u.PasswordHash) > 0
				})).Return(&user.User{
					ID:           "user-123",
					Username:     "testuser",
					Email:        "test@example.com",
					PasswordHash: hashPassword("password123"),
				}, nil).Once()
			},
			expectedUser: &user.User{
				ID:       "user-123",
				Username: "testuser",
				Email:    "test@example.com",
			},
			expectedError: nil,
		},
		{
			name: "error - repository create fails",
			request: &user.CreateUserRequest{
				Username: "testuser",
				Email:    "test@example.com",
				Password: "password123",
			},
			mockSetup: func(userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				userRepo.EXPECT().Create(mock.Anything, mock.Anything).Return(nil, errors.New("db error")).Once()
			},
			expectedUser:  nil,
			expectedError: errors.New("db error"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			userRepo := mocks.NewMockUserRepository(t)
			profileRepo := mocks.NewMockProfileRepository(t)

			tt.mockSetup(userRepo, profileRepo)

			service := NewUserService(userRepo, profileRepo)
			result, err := service.CreateUser(context.Background(), tt.request)

			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
				assert.Nil(t, result)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, result)
				assert.Equal(t, tt.expectedUser.Username, result.Username)
				assert.Equal(t, tt.expectedUser.Email, result.Email)
			}
		})
	}
}

func TestUserService_LoginUser(t *testing.T) {
	hashedPwd := hashPassword("password123")

	tests := []struct {
		name          string
		request       *user.LoginUserRequest
		mockSetup     func(*mocks.MockUserRepository, *mocks.MockProfileRepository)
		expectedUser  *user.User
		expectedError error
	}{
		{
			name: "success - login user",
			request: &user.LoginUserRequest{
				Email:    "test@example.com",
				Password: "password123",
			},
			mockSetup: func(userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				userRepo.EXPECT().GetByEmail(mock.Anything, "test@example.com").Return(&user.User{
					ID:           "user-123",
					Email:        "test@example.com",
					PasswordHash: hashedPwd,
				}, nil).Once()
			},
			expectedUser: &user.User{
				ID:    "user-123",
				Email: "test@example.com",
			},
			expectedError: nil,
		},
		{
			name: "error - user not found",
			request: &user.LoginUserRequest{
				Email:    "nonexistent@example.com",
				Password: "password123",
			},
			mockSetup: func(userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				userRepo.EXPECT().GetByEmail(mock.Anything, "nonexistent@example.com").Return(nil, errors.New("user not found")).Once()
			},
			expectedUser:  nil,
			expectedError: errors.New("user not found"),
		},
		{
			name: "error - incorrect password",
			request: &user.LoginUserRequest{
				Email:    "test@example.com",
				Password: "wrongpassword",
			},
			mockSetup: func(userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				userRepo.EXPECT().GetByEmail(mock.Anything, "test@example.com").Return(&user.User{
					ID:           "user-123",
					Email:        "test@example.com",
					PasswordHash: hashedPwd,
				}, nil).Once()
			},
			expectedUser:  nil,
			expectedError: bcrypt.ErrMismatchedHashAndPassword,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			userRepo := mocks.NewMockUserRepository(t)
			profileRepo := mocks.NewMockProfileRepository(t)

			tt.mockSetup(userRepo, profileRepo)

			service := NewUserService(userRepo, profileRepo)
			result, err := service.LoginUser(context.Background(), tt.request)

			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
				assert.Nil(t, result)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, result)
				assert.Equal(t, tt.expectedUser.Email, result.Email)
			}
		})
	}
}

func TestUserService_UpdateProfile(t *testing.T) {
	tests := []struct {
		name            string
		userID          string
		request         *user.UpdateProfileRequest
		mockSetup       func(*mocks.MockUserRepository, *mocks.MockProfileRepository)
		expectedProfile *user.Profile
		expectedError   error
	}{
		{
			name:   "success - update profile",
			userID: "user-123",
			request: &user.UpdateProfileRequest{
				DisplayName: "Test User",
				AvatarURL:   "http://example.com/avatar.jpg",
			},
			mockSetup: func(userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				profileRepo.EXPECT().Upsert(mock.Anything, mock.MatchedBy(func(p *user.Profile) bool {
					return p.UserID == "user-123" && p.DisplayName == "Test User"
				})).Return(&user.Profile{
					ID:          "profile-456",
					UserID:      "user-123",
					DisplayName: "Test User",
					AvatarURL:   "http://example.com/avatar.jpg",
				}, nil).Once()
			},
			expectedProfile: &user.Profile{
				ID:          "profile-456",
				UserID:      "user-123",
				DisplayName: "Test User",
				AvatarURL:   "http://example.com/avatar.jpg",
			},
			expectedError: nil,
		},
		{
			name:   "error - upsert fails",
			userID: "user-123",
			request: &user.UpdateProfileRequest{
				DisplayName: "Test User",
			},
			mockSetup: func(userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				profileRepo.EXPECT().Upsert(mock.Anything, mock.Anything).Return(nil, errors.New("db error")).Once()
			},
			expectedProfile: nil,
			expectedError:   errors.New("db error"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			userRepo := mocks.NewMockUserRepository(t)
			profileRepo := mocks.NewMockProfileRepository(t)

			tt.mockSetup(userRepo, profileRepo)

			service := NewUserService(userRepo, profileRepo)
			result, err := service.UpdateProfile(context.Background(), tt.userID, tt.request)

			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
				assert.Nil(t, result)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, result)
				assert.Equal(t, tt.expectedProfile.UserID, result.UserID)
				assert.Equal(t, tt.expectedProfile.DisplayName, result.DisplayName)
			}
		})
	}
}

func TestUserService_GetProfile(t *testing.T) {
	tests := []struct {
		name            string
		userID          string
		mockSetup       func(*mocks.MockUserRepository, *mocks.MockProfileRepository)
		expectedProfile *user.Profile
		expectedError   error
	}{
		{
			name:   "success - get profile",
			userID: "user-123",
			mockSetup: func(userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				profileRepo.EXPECT().GetByUserID(mock.Anything, "user-123").Return(&user.Profile{
					ID:     "profile-456",
					UserID: "user-123",
				}, nil).Once()
			},
			expectedProfile: &user.Profile{
				ID:     "profile-456",
				UserID: "user-123",
			},
			expectedError: nil,
		},
		{
			name:   "error - profile not found",
			userID: "user-123",
			mockSetup: func(userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				profileRepo.EXPECT().GetByUserID(mock.Anything, "user-123").Return(nil, errors.New("profile not found")).Once()
			},
			expectedProfile: nil,
			expectedError:   errors.New("profile not found"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			userRepo := mocks.NewMockUserRepository(t)
			profileRepo := mocks.NewMockProfileRepository(t)

			tt.mockSetup(userRepo, profileRepo)

			service := NewUserService(userRepo, profileRepo)
			result, err := service.GetProfile(context.Background(), tt.userID)

			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
				assert.Nil(t, result)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, result)
				assert.Equal(t, tt.expectedProfile.UserID, result.UserID)
			}
		})
	}
}
</file>

<file path="internal/config/config.go">
package config

import (
	"fmt"

	"github.com/joho/godotenv"
	"github.com/kelseyhightower/envconfig"
)

var Empty = new(Config)

type Config struct {
	AppEnv       string `envconfig:"APP_ENV"`
	Port         int    `envconfig:"PORT"`
	SentryDSN    string `envconfig:"SENTRY_DSN"`
	AllowOrigins string `envconfig:"ALLOW_ORIGINS"`
	JWTSecret    string `envconfig:"JWT_SECRET_KEY"`

	DB struct {
		Name      string `envconfig:"DB_NAME"`
		Host      string `envconfig:"DB_HOST"`
		Port      int    `envconfig:"DB_PORT"`
		User      string `envconfig:"DB_USER"`
		Pass      string `envconfig:"DB_PASS"`
		EnableSSL bool   `envconfig:"ENABLE_SSL"`
	}
}

func LoadConfig() (*Config, error) {
	// load default .env file, ignore the error
	_ = godotenv.Load()

	cfg := new(Config)
	err := envconfig.Process("", cfg)
	if err != nil {
		return nil, fmt.Errorf("load config error: %v", err)
	}

	return cfg, nil
}
</file>

<file path="internal/domain/interest_history/interest_history.go">
package interest_history

import (
	"time"
)

type InterestHistory struct {
	ID             string    `json:"id" gorm:"type:uuid;default:gen_random_uuid()"`
	AccountID      string    `json:"account_id" gorm:"not null"`
	Date           time.Time `json:"date" gorm:"type:date;not null"`
	InterestAmount float64   `json:"interest_amount" gorm:"type:numeric(18,2);not null"`
	CreatedAt      time.Time `json:"created_at"`
}
</file>

<file path="internal/domain/transaction/transaction.go">
package transaction

import (
	"time"
)

type Transaction struct {
	ID               string    `json:"id" gorm:"type:uuid;default:gen_random_uuid()"`
	AccountID        string    `json:"account_id" gorm:"not null"`
	TransactionType  string    `json:"transaction_type" gorm:"not null"`
	Amount           float64   `json:"amount" gorm:"type:numeric(18,2);not null"`
	Status           string    `json:"status" gorm:"not null"`
	BalanceAfter     float64   `json:"balance_after" gorm:"type:numeric(18,2);not null"`
	RelatedAccountID *string   `json:"related_account_id"`
	CreatedAt        time.Time `json:"created_at"`
}

const (
	TransactionTypeInterest = "interest"
	TransactionStatusSuccess = "success"
)
</file>

<file path="internal/domain/user/profile.go">
package user

import (
	"time"
)

type Profile struct {
	ID          string    `json:"id"`
	UserID      string    `json:"user_id"`
	DisplayName string    `json:"display_name"`
	AvatarURL   string    `json:"avatar_url"`
	PhoneNumber string    `json:"phone_number"`
	NationalID  string    `json:"national_id"`
	BirthYear   int       `json:"birth_year"`
	Gender      string    `json:"gender"`
	Team        string    `json:"team"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

type UpdateProfileRequest struct {
	Username    string `json:"username"`
	DisplayName string `json:"display_name"`
	AvatarURL   string `json:"avatar_url"`
	PhoneNumber string `json:"phone_number"`
	NationalID  string `json:"national_id"`
	BirthYear   int    `json:"birth_year"`
	Gender      string `json:"gender"`
	Team        string `json:"team"`
}
</file>

<file path="internal/ports/account_service.go">
package ports

import (
	"context"

	"e-wallet/internal/domain/account"
)

type AccountService interface {
	CreatePaymentAccount(ctx context.Context, userID string) (*account.Account, error)
	CreateFixedSavingsAccount(ctx context.Context, userID string, termMonths int) (*account.Account, error)
	CreateFlexibleSavingsAccount(ctx context.Context, userID string) (*account.Account, error)
	CalculateDailyInterest(ctx context.Context) error
}
</file>

<file path="internal/ports/interest_history_repository.go">
package ports

import (
	"context"
	"e-wallet/internal/domain/interest_history"
)

type InterestHistoryRepository interface {
	Create(ctx context.Context, ih *interest_history.InterestHistory) (*interest_history.InterestHistory, error)
}
</file>

<file path="internal/ports/profile_repository.go">
package ports

import (
	"context"
	"e-wallet/internal/domain/user"
)

type ProfileRepository interface {
	Create(ctx context.Context, profile *user.Profile) (*user.Profile, error)
	GetByUserID(ctx context.Context, userID string) (*user.Profile, error)
	Update(ctx context.Context, profile *user.Profile) (*user.Profile, error)
	Upsert(ctx context.Context, profile *user.Profile) (*user.Profile, error)
}
</file>

<file path="internal/ports/transaction_repository.go">
package ports

import (
	"context"
	"e-wallet/internal/domain/transaction"
)

type TransactionRepository interface {
	Create(ctx context.Context, tx *transaction.Transaction) (*transaction.Transaction, error)
}
</file>

<file path="internal/ports/user_service.go">
package ports

import (
	"context"

	"e-wallet/internal/domain/user"
)

type UserService interface {
	CreateUser(ctx context.Context, req *user.CreateUserRequest) (*user.User, error)
	LoginUser(ctx context.Context, req *user.LoginUserRequest) (*user.User, error)
	UpdateProfile(ctx context.Context, userID string, req *user.UpdateProfileRequest) (*user.Profile, error)
	GetProfile(ctx context.Context, userID string) (*user.Profile, error)
}
</file>

<file path="migrations/20250924034000_create_users_table.sql">
-- +migrate Up
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    is_email_verified BOOLEAN DEFAULT FALSE
);
CREATE INDEX idx_users_email ON users(email);

-- +migrate Down
DROP TABLE users;
</file>

<file path="migrations/20250924103000_create_accounts_table.sql">
-- +migrate Up
-- 20240610120000_accounts.sql
CREATE TABLE accounts (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    account_type VARCHAR(20) NOT NULL,
    account_number VARCHAR(30) UNIQUE NOT NULL,
    account_name VARCHAR(100),
    balance NUMERIC(18,2) DEFAULT 0.00,
    interest_rate NUMERIC(5,2),
    fixed_term_months INT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX idx_accounts_user_id ON accounts(user_id);
CREATE INDEX idx_accounts_type ON accounts(account_type);


-- +migrate Down
DROP TABLE accounts;
</file>

<file path="migrations/20250925103100_create_transactions_table.sql">
-- +migrate Up
CREATE TABLE transactions (
    id UUID PRIMARY KEY,
    account_id UUID NOT NULL REFERENCES accounts(id) ON DELETE CASCADE,
    transaction_type VARCHAR(20) NOT NULL,
    amount NUMERIC(18,2) NOT NULL,
    status VARCHAR(20) NOT NULL,
    balance_after NUMERIC(18,2) NOT NULL,
    related_account_id UUID REFERENCES accounts(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX idx_transactions_account_id ON transactions(account_id);
CREATE INDEX idx_transactions_related_account_id ON transactions(related_account_id);
CREATE INDEX idx_transactions_type ON transactions(transaction_type);


-- +migrate Down
DROP TABLE transactions;
</file>

<file path="migrations/20250926034100_create_profiles_table.sql">
-- +migrate Up
CREATE TABLE profiles (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL UNIQUE REFERENCES users(id) ON DELETE CASCADE,
    display_name VARCHAR(100),
    avatar_url TEXT,
    phone_number VARCHAR(15),
    national_id VARCHAR(20),
    birth_year INT,
    gender VARCHAR(10),
    team VARCHAR(20),
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX idx_profiles_user_id ON profiles(user_id);

-- +migrate Down
DROP TABLE profiles;
</file>

<file path="migrations/20250926034200_create_bank_links_table.sql">
-- +migrate Up
CREATE TABLE bank_links (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bank_code VARCHAR(10) NOT NULL,
    account_type VARCHAR(20) NOT NULL,
    access_token VARCHAR(255),
    refresh_token VARCHAR(255),
    expires_in INT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX idx_bank_links_user_id ON bank_links(user_id);
CREATE INDEX idx_bank_links_bank_code ON bank_links(bank_code);

-- +migrate Down
DROP TABLE bank_links;
</file>

<file path="migrations/20250926034300_create_interest_history_table.sql">
-- +migrate Up
CREATE TABLE interest_history (
    id UUID PRIMARY KEY,
    account_id UUID NOT NULL REFERENCES accounts(id) ON DELETE CASCADE,
    date DATE NOT NULL,
    interest_amount NUMERIC(18,2) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX idx_interest_history_account_id ON interest_history(account_id);
CREATE INDEX idx_interest_history_date ON interest_history(date);


-- +migrate Down
DROP TABLE interest_history;
</file>

<file path="mocks/ports_mocks.go">
// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"e-wallet/internal/domain/account"
	"e-wallet/internal/domain/interest_history"
	"e-wallet/internal/domain/transaction"
	"e-wallet/internal/domain/user"

	mock "github.com/stretchr/testify/mock"
)

// NewMockAccountRepository creates a new instance of MockAccountRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAccountRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAccountRepository {
	mock := &MockAccountRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockAccountRepository is an autogenerated mock type for the AccountRepository type
type MockAccountRepository struct {
	mock.Mock
}

type MockAccountRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAccountRepository) EXPECT() *MockAccountRepository_Expecter {
	return &MockAccountRepository_Expecter{mock: &_m.Mock}
}

// CountSavingsAccounts provides a mock function for the type MockAccountRepository
func (_mock *MockAccountRepository) CountSavingsAccounts(ctx context.Context, userID string) (int64, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for CountSavingsAccounts")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (int64, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccountRepository_CountSavingsAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountSavingsAccounts'
type MockAccountRepository_CountSavingsAccounts_Call struct {
	*mock.Call
}

// CountSavingsAccounts is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockAccountRepository_Expecter) CountSavingsAccounts(ctx interface{}, userID interface{}) *MockAccountRepository_CountSavingsAccounts_Call {
	return &MockAccountRepository_CountSavingsAccounts_Call{Call: _e.mock.On("CountSavingsAccounts", ctx, userID)}
}

func (_c *MockAccountRepository_CountSavingsAccounts_Call) Run(run func(ctx context.Context, userID string)) *MockAccountRepository_CountSavingsAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAccountRepository_CountSavingsAccounts_Call) Return(n int64, err error) *MockAccountRepository_CountSavingsAccounts_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockAccountRepository_CountSavingsAccounts_Call) RunAndReturn(run func(ctx context.Context, userID string) (int64, error)) *MockAccountRepository_CountSavingsAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockAccountRepository
func (_mock *MockAccountRepository) Create(ctx context.Context, account1 *account.Account) (*account.Account, error) {
	ret := _mock.Called(ctx, account1)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *account.Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *account.Account) (*account.Account, error)); ok {
		return returnFunc(ctx, account1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *account.Account) *account.Account); ok {
		r0 = returnFunc(ctx, account1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *account.Account) error); ok {
		r1 = returnFunc(ctx, account1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccountRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockAccountRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - account1 *account.Account
func (_e *MockAccountRepository_Expecter) Create(ctx interface{}, account1 interface{}) *MockAccountRepository_Create_Call {
	return &MockAccountRepository_Create_Call{Call: _e.mock.On("Create", ctx, account1)}
}

func (_c *MockAccountRepository_Create_Call) Run(run func(ctx context.Context, account1 *account.Account)) *MockAccountRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *account.Account
		if args[1] != nil {
			arg1 = args[1].(*account.Account)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAccountRepository_Create_Call) Return(account11 *account.Account, err error) *MockAccountRepository_Create_Call {
	_c.Call.Return(account11, err)
	return _c
}

func (_c *MockAccountRepository_Create_Call) RunAndReturn(run func(ctx context.Context, account1 *account.Account) (*account.Account, error)) *MockAccountRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// GetByID provides a mock function for the type MockAccountRepository
func (_mock *MockAccountRepository) GetByID(ctx context.Context, id string) (*account.Account, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 *account.Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*account.Account, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *account.Account); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccountRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockAccountRepository_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockAccountRepository_Expecter) GetByID(ctx interface{}, id interface{}) *MockAccountRepository_GetByID_Call {
	return &MockAccountRepository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, id)}
}

func (_c *MockAccountRepository_GetByID_Call) Run(run func(ctx context.Context, id string)) *MockAccountRepository_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAccountRepository_GetByID_Call) Return(account1 *account.Account, err error) *MockAccountRepository_GetByID_Call {
	_c.Call.Return(account1, err)
	return _c
}

func (_c *MockAccountRepository_GetByID_Call) RunAndReturn(run func(ctx context.Context, id string) (*account.Account, error)) *MockAccountRepository_GetByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetByUserID provides a mock function for the type MockAccountRepository
func (_mock *MockAccountRepository) GetByUserID(ctx context.Context, userID string) (*account.Account, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetByUserID")
	}

	var r0 *account.Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*account.Account, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *account.Account); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccountRepository_GetByUserID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByUserID'
type MockAccountRepository_GetByUserID_Call struct {
	*mock.Call
}

// GetByUserID is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockAccountRepository_Expecter) GetByUserID(ctx interface{}, userID interface{}) *MockAccountRepository_GetByUserID_Call {
	return &MockAccountRepository_GetByUserID_Call{Call: _e.mock.On("GetByUserID", ctx, userID)}
}

func (_c *MockAccountRepository_GetByUserID_Call) Run(run func(ctx context.Context, userID string)) *MockAccountRepository_GetByUserID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAccountRepository_GetByUserID_Call) Return(account1 *account.Account, err error) *MockAccountRepository_GetByUserID_Call {
	_c.Call.Return(account1, err)
	return _c
}

func (_c *MockAccountRepository_GetByUserID_Call) RunAndReturn(run func(ctx context.Context, userID string) (*account.Account, error)) *MockAccountRepository_GetByUserID_Call {
	_c.Call.Return(run)
	return _c
}

// GetFlexibleSavingsAccounts provides a mock function for the type MockAccountRepository
func (_mock *MockAccountRepository) GetFlexibleSavingsAccounts(ctx context.Context) ([]*account.Account, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetFlexibleSavingsAccounts")
	}

	var r0 []*account.Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]*account.Account, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []*account.Account); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*account.Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccountRepository_GetFlexibleSavingsAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFlexibleSavingsAccounts'
type MockAccountRepository_GetFlexibleSavingsAccounts_Call struct {
	*mock.Call
}

// GetFlexibleSavingsAccounts is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockAccountRepository_Expecter) GetFlexibleSavingsAccounts(ctx interface{}) *MockAccountRepository_GetFlexibleSavingsAccounts_Call {
	return &MockAccountRepository_GetFlexibleSavingsAccounts_Call{Call: _e.mock.On("GetFlexibleSavingsAccounts", ctx)}
}

func (_c *MockAccountRepository_GetFlexibleSavingsAccounts_Call) Run(run func(ctx context.Context)) *MockAccountRepository_GetFlexibleSavingsAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockAccountRepository_GetFlexibleSavingsAccounts_Call) Return(accounts []*account.Account, err error) *MockAccountRepository_GetFlexibleSavingsAccounts_Call {
	_c.Call.Return(accounts, err)
	return _c
}

func (_c *MockAccountRepository_GetFlexibleSavingsAccounts_Call) RunAndReturn(run func(ctx context.Context) ([]*account.Account, error)) *MockAccountRepository_GetFlexibleSavingsAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateBalance provides a mock function for the type MockAccountRepository
func (_mock *MockAccountRepository) UpdateBalance(ctx context.Context, id string, balance float64) error {
	ret := _mock.Called(ctx, id, balance)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBalance")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, float64) error); ok {
		r0 = returnFunc(ctx, id, balance)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockAccountRepository_UpdateBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateBalance'
type MockAccountRepository_UpdateBalance_Call struct {
	*mock.Call
}

// UpdateBalance is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - balance float64
func (_e *MockAccountRepository_Expecter) UpdateBalance(ctx interface{}, id interface{}, balance interface{}) *MockAccountRepository_UpdateBalance_Call {
	return &MockAccountRepository_UpdateBalance_Call{Call: _e.mock.On("UpdateBalance", ctx, id, balance)}
}

func (_c *MockAccountRepository_UpdateBalance_Call) Run(run func(ctx context.Context, id string, balance float64)) *MockAccountRepository_UpdateBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 float64
		if args[2] != nil {
			arg2 = args[2].(float64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockAccountRepository_UpdateBalance_Call) Return(err error) *MockAccountRepository_UpdateBalance_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockAccountRepository_UpdateBalance_Call) RunAndReturn(run func(ctx context.Context, id string, balance float64) error) *MockAccountRepository_UpdateBalance_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockAccountService creates a new instance of MockAccountService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAccountService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAccountService {
	mock := &MockAccountService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockAccountService is an autogenerated mock type for the AccountService type
type MockAccountService struct {
	mock.Mock
}

type MockAccountService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAccountService) EXPECT() *MockAccountService_Expecter {
	return &MockAccountService_Expecter{mock: &_m.Mock}
}

// CalculateDailyInterest provides a mock function for the type MockAccountService
func (_mock *MockAccountService) CalculateDailyInterest(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CalculateDailyInterest")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockAccountService_CalculateDailyInterest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CalculateDailyInterest'
type MockAccountService_CalculateDailyInterest_Call struct {
	*mock.Call
}

// CalculateDailyInterest is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockAccountService_Expecter) CalculateDailyInterest(ctx interface{}) *MockAccountService_CalculateDailyInterest_Call {
	return &MockAccountService_CalculateDailyInterest_Call{Call: _e.mock.On("CalculateDailyInterest", ctx)}
}

func (_c *MockAccountService_CalculateDailyInterest_Call) Run(run func(ctx context.Context)) *MockAccountService_CalculateDailyInterest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockAccountService_CalculateDailyInterest_Call) Return(err error) *MockAccountService_CalculateDailyInterest_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockAccountService_CalculateDailyInterest_Call) RunAndReturn(run func(ctx context.Context) error) *MockAccountService_CalculateDailyInterest_Call {
	_c.Call.Return(run)
	return _c
}

// CreateFixedSavingsAccount provides a mock function for the type MockAccountService
func (_mock *MockAccountService) CreateFixedSavingsAccount(ctx context.Context, userID string, termMonths int) (*account.Account, error) {
	ret := _mock.Called(ctx, userID, termMonths)

	if len(ret) == 0 {
		panic("no return value specified for CreateFixedSavingsAccount")
	}

	var r0 *account.Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int) (*account.Account, error)); ok {
		return returnFunc(ctx, userID, termMonths)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int) *account.Account); ok {
		r0 = returnFunc(ctx, userID, termMonths)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, int) error); ok {
		r1 = returnFunc(ctx, userID, termMonths)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccountService_CreateFixedSavingsAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateFixedSavingsAccount'
type MockAccountService_CreateFixedSavingsAccount_Call struct {
	*mock.Call
}

// CreateFixedSavingsAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - termMonths int
func (_e *MockAccountService_Expecter) CreateFixedSavingsAccount(ctx interface{}, userID interface{}, termMonths interface{}) *MockAccountService_CreateFixedSavingsAccount_Call {
	return &MockAccountService_CreateFixedSavingsAccount_Call{Call: _e.mock.On("CreateFixedSavingsAccount", ctx, userID, termMonths)}
}

func (_c *MockAccountService_CreateFixedSavingsAccount_Call) Run(run func(ctx context.Context, userID string, termMonths int)) *MockAccountService_CreateFixedSavingsAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockAccountService_CreateFixedSavingsAccount_Call) Return(account1 *account.Account, err error) *MockAccountService_CreateFixedSavingsAccount_Call {
	_c.Call.Return(account1, err)
	return _c
}

func (_c *MockAccountService_CreateFixedSavingsAccount_Call) RunAndReturn(run func(ctx context.Context, userID string, termMonths int) (*account.Account, error)) *MockAccountService_CreateFixedSavingsAccount_Call {
	_c.Call.Return(run)
	return _c
}

// CreateFlexibleSavingsAccount provides a mock function for the type MockAccountService
func (_mock *MockAccountService) CreateFlexibleSavingsAccount(ctx context.Context, userID string) (*account.Account, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for CreateFlexibleSavingsAccount")
	}

	var r0 *account.Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*account.Account, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *account.Account); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccountService_CreateFlexibleSavingsAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateFlexibleSavingsAccount'
type MockAccountService_CreateFlexibleSavingsAccount_Call struct {
	*mock.Call
}

// CreateFlexibleSavingsAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockAccountService_Expecter) CreateFlexibleSavingsAccount(ctx interface{}, userID interface{}) *MockAccountService_CreateFlexibleSavingsAccount_Call {
	return &MockAccountService_CreateFlexibleSavingsAccount_Call{Call: _e.mock.On("CreateFlexibleSavingsAccount", ctx, userID)}
}

func (_c *MockAccountService_CreateFlexibleSavingsAccount_Call) Run(run func(ctx context.Context, userID string)) *MockAccountService_CreateFlexibleSavingsAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAccountService_CreateFlexibleSavingsAccount_Call) Return(account1 *account.Account, err error) *MockAccountService_CreateFlexibleSavingsAccount_Call {
	_c.Call.Return(account1, err)
	return _c
}

func (_c *MockAccountService_CreateFlexibleSavingsAccount_Call) RunAndReturn(run func(ctx context.Context, userID string) (*account.Account, error)) *MockAccountService_CreateFlexibleSavingsAccount_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePaymentAccount provides a mock function for the type MockAccountService
func (_mock *MockAccountService) CreatePaymentAccount(ctx context.Context, userID string) (*account.Account, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for CreatePaymentAccount")
	}

	var r0 *account.Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*account.Account, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *account.Account); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccountService_CreatePaymentAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePaymentAccount'
type MockAccountService_CreatePaymentAccount_Call struct {
	*mock.Call
}

// CreatePaymentAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockAccountService_Expecter) CreatePaymentAccount(ctx interface{}, userID interface{}) *MockAccountService_CreatePaymentAccount_Call {
	return &MockAccountService_CreatePaymentAccount_Call{Call: _e.mock.On("CreatePaymentAccount", ctx, userID)}
}

func (_c *MockAccountService_CreatePaymentAccount_Call) Run(run func(ctx context.Context, userID string)) *MockAccountService_CreatePaymentAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAccountService_CreatePaymentAccount_Call) Return(account1 *account.Account, err error) *MockAccountService_CreatePaymentAccount_Call {
	_c.Call.Return(account1, err)
	return _c
}

func (_c *MockAccountService_CreatePaymentAccount_Call) RunAndReturn(run func(ctx context.Context, userID string) (*account.Account, error)) *MockAccountService_CreatePaymentAccount_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockInterestHistoryRepository creates a new instance of MockInterestHistoryRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockInterestHistoryRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockInterestHistoryRepository {
	mock := &MockInterestHistoryRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockInterestHistoryRepository is an autogenerated mock type for the InterestHistoryRepository type
type MockInterestHistoryRepository struct {
	mock.Mock
}

type MockInterestHistoryRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockInterestHistoryRepository) EXPECT() *MockInterestHistoryRepository_Expecter {
	return &MockInterestHistoryRepository_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockInterestHistoryRepository
func (_mock *MockInterestHistoryRepository) Create(ctx context.Context, ih *interest_history.InterestHistory) (*interest_history.InterestHistory, error) {
	ret := _mock.Called(ctx, ih)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *interest_history.InterestHistory
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *interest_history.InterestHistory) (*interest_history.InterestHistory, error)); ok {
		return returnFunc(ctx, ih)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *interest_history.InterestHistory) *interest_history.InterestHistory); ok {
		r0 = returnFunc(ctx, ih)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*interest_history.InterestHistory)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *interest_history.InterestHistory) error); ok {
		r1 = returnFunc(ctx, ih)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockInterestHistoryRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockInterestHistoryRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - ih *interest_history.InterestHistory
func (_e *MockInterestHistoryRepository_Expecter) Create(ctx interface{}, ih interface{}) *MockInterestHistoryRepository_Create_Call {
	return &MockInterestHistoryRepository_Create_Call{Call: _e.mock.On("Create", ctx, ih)}
}

func (_c *MockInterestHistoryRepository_Create_Call) Run(run func(ctx context.Context, ih *interest_history.InterestHistory)) *MockInterestHistoryRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *interest_history.InterestHistory
		if args[1] != nil {
			arg1 = args[1].(*interest_history.InterestHistory)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockInterestHistoryRepository_Create_Call) Return(interestHistory *interest_history.InterestHistory, err error) *MockInterestHistoryRepository_Create_Call {
	_c.Call.Return(interestHistory, err)
	return _c
}

func (_c *MockInterestHistoryRepository_Create_Call) RunAndReturn(run func(ctx context.Context, ih *interest_history.InterestHistory) (*interest_history.InterestHistory, error)) *MockInterestHistoryRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProfileRepository creates a new instance of MockProfileRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProfileRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProfileRepository {
	mock := &MockProfileRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockProfileRepository is an autogenerated mock type for the ProfileRepository type
type MockProfileRepository struct {
	mock.Mock
}

type MockProfileRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProfileRepository) EXPECT() *MockProfileRepository_Expecter {
	return &MockProfileRepository_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockProfileRepository
func (_mock *MockProfileRepository) Create(ctx context.Context, profile *user.Profile) (*user.Profile, error) {
	ret := _mock.Called(ctx, profile)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *user.Profile
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.Profile) (*user.Profile, error)); ok {
		return returnFunc(ctx, profile)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.Profile) *user.Profile); ok {
		r0 = returnFunc(ctx, profile)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.Profile)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *user.Profile) error); ok {
		r1 = returnFunc(ctx, profile)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProfileRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockProfileRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - profile *user.Profile
func (_e *MockProfileRepository_Expecter) Create(ctx interface{}, profile interface{}) *MockProfileRepository_Create_Call {
	return &MockProfileRepository_Create_Call{Call: _e.mock.On("Create", ctx, profile)}
}

func (_c *MockProfileRepository_Create_Call) Run(run func(ctx context.Context, profile *user.Profile)) *MockProfileRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *user.Profile
		if args[1] != nil {
			arg1 = args[1].(*user.Profile)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProfileRepository_Create_Call) Return(profile1 *user.Profile, err error) *MockProfileRepository_Create_Call {
	_c.Call.Return(profile1, err)
	return _c
}

func (_c *MockProfileRepository_Create_Call) RunAndReturn(run func(ctx context.Context, profile *user.Profile) (*user.Profile, error)) *MockProfileRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// GetByUserID provides a mock function for the type MockProfileRepository
func (_mock *MockProfileRepository) GetByUserID(ctx context.Context, userID string) (*user.Profile, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetByUserID")
	}

	var r0 *user.Profile
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*user.Profile, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *user.Profile); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.Profile)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProfileRepository_GetByUserID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByUserID'
type MockProfileRepository_GetByUserID_Call struct {
	*mock.Call
}

// GetByUserID is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockProfileRepository_Expecter) GetByUserID(ctx interface{}, userID interface{}) *MockProfileRepository_GetByUserID_Call {
	return &MockProfileRepository_GetByUserID_Call{Call: _e.mock.On("GetByUserID", ctx, userID)}
}

func (_c *MockProfileRepository_GetByUserID_Call) Run(run func(ctx context.Context, userID string)) *MockProfileRepository_GetByUserID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProfileRepository_GetByUserID_Call) Return(profile *user.Profile, err error) *MockProfileRepository_GetByUserID_Call {
	_c.Call.Return(profile, err)
	return _c
}

func (_c *MockProfileRepository_GetByUserID_Call) RunAndReturn(run func(ctx context.Context, userID string) (*user.Profile, error)) *MockProfileRepository_GetByUserID_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type MockProfileRepository
func (_mock *MockProfileRepository) Update(ctx context.Context, profile *user.Profile) (*user.Profile, error) {
	ret := _mock.Called(ctx, profile)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 *user.Profile
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.Profile) (*user.Profile, error)); ok {
		return returnFunc(ctx, profile)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.Profile) *user.Profile); ok {
		r0 = returnFunc(ctx, profile)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.Profile)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *user.Profile) error); ok {
		r1 = returnFunc(ctx, profile)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProfileRepository_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockProfileRepository_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - profile *user.Profile
func (_e *MockProfileRepository_Expecter) Update(ctx interface{}, profile interface{}) *MockProfileRepository_Update_Call {
	return &MockProfileRepository_Update_Call{Call: _e.mock.On("Update", ctx, profile)}
}

func (_c *MockProfileRepository_Update_Call) Run(run func(ctx context.Context, profile *user.Profile)) *MockProfileRepository_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *user.Profile
		if args[1] != nil {
			arg1 = args[1].(*user.Profile)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProfileRepository_Update_Call) Return(profile1 *user.Profile, err error) *MockProfileRepository_Update_Call {
	_c.Call.Return(profile1, err)
	return _c
}

func (_c *MockProfileRepository_Update_Call) RunAndReturn(run func(ctx context.Context, profile *user.Profile) (*user.Profile, error)) *MockProfileRepository_Update_Call {
	_c.Call.Return(run)
	return _c
}

// Upsert provides a mock function for the type MockProfileRepository
func (_mock *MockProfileRepository) Upsert(ctx context.Context, profile *user.Profile) (*user.Profile, error) {
	ret := _mock.Called(ctx, profile)

	if len(ret) == 0 {
		panic("no return value specified for Upsert")
	}

	var r0 *user.Profile
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.Profile) (*user.Profile, error)); ok {
		return returnFunc(ctx, profile)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.Profile) *user.Profile); ok {
		r0 = returnFunc(ctx, profile)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.Profile)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *user.Profile) error); ok {
		r1 = returnFunc(ctx, profile)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProfileRepository_Upsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Upsert'
type MockProfileRepository_Upsert_Call struct {
	*mock.Call
}

// Upsert is a helper method to define mock.On call
//   - ctx context.Context
//   - profile *user.Profile
func (_e *MockProfileRepository_Expecter) Upsert(ctx interface{}, profile interface{}) *MockProfileRepository_Upsert_Call {
	return &MockProfileRepository_Upsert_Call{Call: _e.mock.On("Upsert", ctx, profile)}
}

func (_c *MockProfileRepository_Upsert_Call) Run(run func(ctx context.Context, profile *user.Profile)) *MockProfileRepository_Upsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *user.Profile
		if args[1] != nil {
			arg1 = args[1].(*user.Profile)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProfileRepository_Upsert_Call) Return(profile1 *user.Profile, err error) *MockProfileRepository_Upsert_Call {
	_c.Call.Return(profile1, err)
	return _c
}

func (_c *MockProfileRepository_Upsert_Call) RunAndReturn(run func(ctx context.Context, profile *user.Profile) (*user.Profile, error)) *MockProfileRepository_Upsert_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockTransactionRepository creates a new instance of MockTransactionRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTransactionRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTransactionRepository {
	mock := &MockTransactionRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTransactionRepository is an autogenerated mock type for the TransactionRepository type
type MockTransactionRepository struct {
	mock.Mock
}

type MockTransactionRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTransactionRepository) EXPECT() *MockTransactionRepository_Expecter {
	return &MockTransactionRepository_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockTransactionRepository
func (_mock *MockTransactionRepository) Create(ctx context.Context, tx *transaction.Transaction) (*transaction.Transaction, error) {
	ret := _mock.Called(ctx, tx)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *transaction.Transaction
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *transaction.Transaction) (*transaction.Transaction, error)); ok {
		return returnFunc(ctx, tx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *transaction.Transaction) *transaction.Transaction); ok {
		r0 = returnFunc(ctx, tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transaction.Transaction)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *transaction.Transaction) error); ok {
		r1 = returnFunc(ctx, tx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTransactionRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockTransactionRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - tx *transaction.Transaction
func (_e *MockTransactionRepository_Expecter) Create(ctx interface{}, tx interface{}) *MockTransactionRepository_Create_Call {
	return &MockTransactionRepository_Create_Call{Call: _e.mock.On("Create", ctx, tx)}
}

func (_c *MockTransactionRepository_Create_Call) Run(run func(ctx context.Context, tx *transaction.Transaction)) *MockTransactionRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *transaction.Transaction
		if args[1] != nil {
			arg1 = args[1].(*transaction.Transaction)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTransactionRepository_Create_Call) Return(transaction1 *transaction.Transaction, err error) *MockTransactionRepository_Create_Call {
	_c.Call.Return(transaction1, err)
	return _c
}

func (_c *MockTransactionRepository_Create_Call) RunAndReturn(run func(ctx context.Context, tx *transaction.Transaction) (*transaction.Transaction, error)) *MockTransactionRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUserRepository creates a new instance of MockUserRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUserRepository {
	mock := &MockUserRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUserRepository is an autogenerated mock type for the UserRepository type
type MockUserRepository struct {
	mock.Mock
}

type MockUserRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUserRepository) EXPECT() *MockUserRepository_Expecter {
	return &MockUserRepository_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) Create(ctx context.Context, user1 *user.User) (*user.User, error) {
	ret := _mock.Called(ctx, user1)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *user.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.User) (*user.User, error)); ok {
		return returnFunc(ctx, user1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.User) *user.User); ok {
		r0 = returnFunc(ctx, user1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *user.User) error); ok {
		r1 = returnFunc(ctx, user1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockUserRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - user1 *user.User
func (_e *MockUserRepository_Expecter) Create(ctx interface{}, user1 interface{}) *MockUserRepository_Create_Call {
	return &MockUserRepository_Create_Call{Call: _e.mock.On("Create", ctx, user1)}
}

func (_c *MockUserRepository_Create_Call) Run(run func(ctx context.Context, user1 *user.User)) *MockUserRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *user.User
		if args[1] != nil {
			arg1 = args[1].(*user.User)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserRepository_Create_Call) Return(user11 *user.User, err error) *MockUserRepository_Create_Call {
	_c.Call.Return(user11, err)
	return _c
}

func (_c *MockUserRepository_Create_Call) RunAndReturn(run func(ctx context.Context, user1 *user.User) (*user.User, error)) *MockUserRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// GetByEmail provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) GetByEmail(ctx context.Context, email string) (*user.User, error) {
	ret := _mock.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for GetByEmail")
	}

	var r0 *user.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*user.User, error)); ok {
		return returnFunc(ctx, email)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *user.User); ok {
		r0 = returnFunc(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, email)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserRepository_GetByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByEmail'
type MockUserRepository_GetByEmail_Call struct {
	*mock.Call
}

// GetByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *MockUserRepository_Expecter) GetByEmail(ctx interface{}, email interface{}) *MockUserRepository_GetByEmail_Call {
	return &MockUserRepository_GetByEmail_Call{Call: _e.mock.On("GetByEmail", ctx, email)}
}

func (_c *MockUserRepository_GetByEmail_Call) Run(run func(ctx context.Context, email string)) *MockUserRepository_GetByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserRepository_GetByEmail_Call) Return(user1 *user.User, err error) *MockUserRepository_GetByEmail_Call {
	_c.Call.Return(user1, err)
	return _c
}

func (_c *MockUserRepository_GetByEmail_Call) RunAndReturn(run func(ctx context.Context, email string) (*user.User, error)) *MockUserRepository_GetByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// GetByID provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) GetByID(ctx context.Context, id string) (*user.User, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 *user.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*user.User, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *user.User); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockUserRepository_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockUserRepository_Expecter) GetByID(ctx interface{}, id interface{}) *MockUserRepository_GetByID_Call {
	return &MockUserRepository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, id)}
}

func (_c *MockUserRepository_GetByID_Call) Run(run func(ctx context.Context, id string)) *MockUserRepository_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserRepository_GetByID_Call) Return(user1 *user.User, err error) *MockUserRepository_GetByID_Call {
	_c.Call.Return(user1, err)
	return _c
}

func (_c *MockUserRepository_GetByID_Call) RunAndReturn(run func(ctx context.Context, id string) (*user.User, error)) *MockUserRepository_GetByID_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUserService creates a new instance of MockUserService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUserService {
	mock := &MockUserService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUserService is an autogenerated mock type for the UserService type
type MockUserService struct {
	mock.Mock
}

type MockUserService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUserService) EXPECT() *MockUserService_Expecter {
	return &MockUserService_Expecter{mock: &_m.Mock}
}

// CreateUser provides a mock function for the type MockUserService
func (_mock *MockUserService) CreateUser(ctx context.Context, req *user.CreateUserRequest) (*user.User, error) {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 *user.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.CreateUserRequest) (*user.User, error)); ok {
		return returnFunc(ctx, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.CreateUserRequest) *user.User); ok {
		r0 = returnFunc(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *user.CreateUserRequest) error); ok {
		r1 = returnFunc(ctx, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserService_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type MockUserService_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - req *user.CreateUserRequest
func (_e *MockUserService_Expecter) CreateUser(ctx interface{}, req interface{}) *MockUserService_CreateUser_Call {
	return &MockUserService_CreateUser_Call{Call: _e.mock.On("CreateUser", ctx, req)}
}

func (_c *MockUserService_CreateUser_Call) Run(run func(ctx context.Context, req *user.CreateUserRequest)) *MockUserService_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *user.CreateUserRequest
		if args[1] != nil {
			arg1 = args[1].(*user.CreateUserRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserService_CreateUser_Call) Return(user1 *user.User, err error) *MockUserService_CreateUser_Call {
	_c.Call.Return(user1, err)
	return _c
}

func (_c *MockUserService_CreateUser_Call) RunAndReturn(run func(ctx context.Context, req *user.CreateUserRequest) (*user.User, error)) *MockUserService_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetProfile provides a mock function for the type MockUserService
func (_mock *MockUserService) GetProfile(ctx context.Context, userID string) (*user.Profile, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetProfile")
	}

	var r0 *user.Profile
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*user.Profile, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *user.Profile); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.Profile)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserService_GetProfile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProfile'
type MockUserService_GetProfile_Call struct {
	*mock.Call
}

// GetProfile is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockUserService_Expecter) GetProfile(ctx interface{}, userID interface{}) *MockUserService_GetProfile_Call {
	return &MockUserService_GetProfile_Call{Call: _e.mock.On("GetProfile", ctx, userID)}
}

func (_c *MockUserService_GetProfile_Call) Run(run func(ctx context.Context, userID string)) *MockUserService_GetProfile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserService_GetProfile_Call) Return(profile *user.Profile, err error) *MockUserService_GetProfile_Call {
	_c.Call.Return(profile, err)
	return _c
}

func (_c *MockUserService_GetProfile_Call) RunAndReturn(run func(ctx context.Context, userID string) (*user.Profile, error)) *MockUserService_GetProfile_Call {
	_c.Call.Return(run)
	return _c
}

// LoginUser provides a mock function for the type MockUserService
func (_mock *MockUserService) LoginUser(ctx context.Context, req *user.LoginUserRequest) (*user.User, error) {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for LoginUser")
	}

	var r0 *user.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.LoginUserRequest) (*user.User, error)); ok {
		return returnFunc(ctx, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.LoginUserRequest) *user.User); ok {
		r0 = returnFunc(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *user.LoginUserRequest) error); ok {
		r1 = returnFunc(ctx, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserService_LoginUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoginUser'
type MockUserService_LoginUser_Call struct {
	*mock.Call
}

// LoginUser is a helper method to define mock.On call
//   - ctx context.Context
//   - req *user.LoginUserRequest
func (_e *MockUserService_Expecter) LoginUser(ctx interface{}, req interface{}) *MockUserService_LoginUser_Call {
	return &MockUserService_LoginUser_Call{Call: _e.mock.On("LoginUser", ctx, req)}
}

func (_c *MockUserService_LoginUser_Call) Run(run func(ctx context.Context, req *user.LoginUserRequest)) *MockUserService_LoginUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *user.LoginUserRequest
		if args[1] != nil {
			arg1 = args[1].(*user.LoginUserRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserService_LoginUser_Call) Return(user1 *user.User, err error) *MockUserService_LoginUser_Call {
	_c.Call.Return(user1, err)
	return _c
}

func (_c *MockUserService_LoginUser_Call) RunAndReturn(run func(ctx context.Context, req *user.LoginUserRequest) (*user.User, error)) *MockUserService_LoginUser_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProfile provides a mock function for the type MockUserService
func (_mock *MockUserService) UpdateProfile(ctx context.Context, userID string, req *user.UpdateProfileRequest) (*user.Profile, error) {
	ret := _mock.Called(ctx, userID, req)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProfile")
	}

	var r0 *user.Profile
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *user.UpdateProfileRequest) (*user.Profile, error)); ok {
		return returnFunc(ctx, userID, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *user.UpdateProfileRequest) *user.Profile); ok {
		r0 = returnFunc(ctx, userID, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.Profile)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, *user.UpdateProfileRequest) error); ok {
		r1 = returnFunc(ctx, userID, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserService_UpdateProfile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProfile'
type MockUserService_UpdateProfile_Call struct {
	*mock.Call
}

// UpdateProfile is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - req *user.UpdateProfileRequest
func (_e *MockUserService_Expecter) UpdateProfile(ctx interface{}, userID interface{}, req interface{}) *MockUserService_UpdateProfile_Call {
	return &MockUserService_UpdateProfile_Call{Call: _e.mock.On("UpdateProfile", ctx, userID, req)}
}

func (_c *MockUserService_UpdateProfile_Call) Run(run func(ctx context.Context, userID string, req *user.UpdateProfileRequest)) *MockUserService_UpdateProfile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 *user.UpdateProfileRequest
		if args[2] != nil {
			arg2 = args[2].(*user.UpdateProfileRequest)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockUserService_UpdateProfile_Call) Return(profile *user.Profile, err error) *MockUserService_UpdateProfile_Call {
	_c.Call.Return(profile, err)
	return _c
}

func (_c *MockUserService_UpdateProfile_Call) RunAndReturn(run func(ctx context.Context, userID string, req *user.UpdateProfileRequest) (*user.Profile, error)) *MockUserService_UpdateProfile_Call {
	_c.Call.Return(run)
	return _c
}
</file>

<file path="pkg/logger/logger.go">
package logger

import (
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

// NOOPLogger use for unit testing
var NOOPLogger = zap.NewNop().Sugar()

func NewAppLogger() (*zap.SugaredLogger, error) {
	cfg := zap.NewProductionConfig()
	cfg.EncoderConfig.TimeKey = "timestamp"
	cfg.EncoderConfig.EncodeTime = zapcore.RFC3339TimeEncoder
	cfg.EncoderConfig.CallerKey = "func"
	cfg.EncoderConfig.EncodeCaller = zapcore.FullCallerEncoder

	logger, err := cfg.Build()
	if err != nil {
		return nil, err
	}

	return logger.Sugar(), nil
}

func Sync(l *zap.SugaredLogger) {
	if err := l.Sync(); err != nil {
		l.Error("cannot sync logger: ", err)
	}
}
</file>

<file path="pkg/sentry/sentry.go">
package sentry

import (
	"fmt"
	"os"
	"time"

	sentrygo "github.com/getsentry/sentry-go"
	sentryecho "github.com/getsentry/sentry-go/echo"
	"github.com/labstack/echo/v4"
)

var FlushTime = time.Second * 5

// Sentry hold information for a sentry scope
type Sentry struct {
	context       echo.Context
	error         error
	message       string
	level         sentrygo.Level
	extras        map[string]interface{}
	tags          map[string]string
	contextValues map[string]sentrygo.Context
}

func (s *Sentry) WithContext(c echo.Context) *Sentry {
	s.context = c
	return s
}

func (s *Sentry) WithError(err error) *Sentry {
	s.error = err
	return s
}

func (s *Sentry) WithMessage(message string) *Sentry {
	s.message = message
	return s
}

func (s *Sentry) WithLevel(level sentrygo.Level) *Sentry {
	s.level = level
	return s
}

func (s *Sentry) WithExtras(extras map[string]interface{}) *Sentry {
	s.extras = extras
	return s
}

func (s *Sentry) WithTags(tags map[string]string) *Sentry {
	s.tags = tags
	return s
}

func (s *Sentry) WithContextValues(ctx map[string]sentrygo.Context) *Sentry {
	s.contextValues = ctx
	return s
}

// configScope configure all information into current scope
func (s *Sentry) configScope(scope *sentrygo.Scope) {
	// set level
	scope.SetLevel(s.level)
	// set extras
	scope.SetExtras(s.extras)
	// set tags
	scope.SetTags(s.tags)
	// set context values
	scope.SetContexts(s.contextValues)
}

func (s *Sentry) getHub() *sentrygo.Hub {
	currentHub := sentrygo.CurrentHub().Clone()
	if s.context != nil {
		hub := sentryecho.GetHubFromContext(s.context)
		if hub != nil {
			currentHub = hub
		}
	}
	return currentHub
}

func (s *Sentry) sendError() {
	if os.Getenv("APP_ENV") == "local" || len(os.Getenv("SENTRY_DSN")) == 0 {
		return
	}

	hub := s.getHub()

	// config basic info into scope
	hub.ConfigureScope(s.configScope)
	// capture error and send
	hub.CaptureException(s.error)
	// clear context data
	hub.ConfigureScope(func(scope *sentrygo.Scope) {
		scope.Clear()
	})
}

func (s *Sentry) sendMessage() {
	if os.Getenv("APP_ENV") == "local" || len(os.Getenv("SENTRY_DSN")) == 0 {
		return
	}

	hub := s.getHub()

	// config basic info into scope
	hub.ConfigureScope(s.configScope)
	// capture message and send
	hub.CaptureMessage(s.message)
	// clear context data
	hub.ConfigureScope(func(scope *sentrygo.Scope) {
		scope.Clear()
	})
}

func (s *Sentry) Debug(message string) {
	s.WithMessage(message).WithLevel(sentrygo.LevelDebug).sendMessage()
}

func (s *Sentry) Debugf(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	s.WithMessage(msg).WithLevel(sentrygo.LevelDebug).sendMessage()
}

func (s *Sentry) Info(message string) {
	s.WithMessage(message).WithLevel(sentrygo.LevelInfo).sendMessage()
}

func (s *Sentry) Infof(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	s.WithMessage(msg).WithLevel(sentrygo.LevelInfo).sendMessage()
}

func (s *Sentry) Warning(message string) {
	s.WithMessage(message).WithLevel(sentrygo.LevelWarning).sendMessage()
}

func (s *Sentry) Warningf(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	s.WithMessage(msg).WithLevel(sentrygo.LevelWarning).sendMessage()
}

func (s *Sentry) Error(err error) {
	s.WithError(err).WithLevel(sentrygo.LevelError).sendError()
}

func (s *Sentry) Errorf(format string, args ...interface{}) {
	err := fmt.Errorf(format, args...)
	s.WithError(err).WithLevel(sentrygo.LevelError).sendError()
}

func (s *Sentry) Fatal(err error) {
	s.WithError(err).WithLevel(sentrygo.LevelFatal).sendError()
	sentrygo.Flush(FlushTime)
}

func (s *Sentry) Fatalf(format string, args ...interface{}) {
	err := fmt.Errorf(format, args...)
	s.WithError(err).WithLevel(sentrygo.LevelFatal).sendError()
	sentrygo.Flush(FlushTime)
}

// Convenient functions. Use directly, no need to create sentry instance
func createSentry() *Sentry {
	return new(Sentry)
}

// WithContext set context into the current scope
func WithContext(c echo.Context) *Sentry {
	sentry := createSentry()
	sentry.WithContext(c)
	return sentry
}

// WithExtras set extras infor into current scope
func WithExtras(extras map[string]interface{}) *Sentry {
	sentry := createSentry()
	sentry.WithExtras(extras)
	return sentry
}

// WithTags set extras infor into current scope
func WithTags(tags map[string]string) *Sentry {
	sentry := createSentry()
	sentry.WithTags(tags)
	return sentry
}

// WithContextValues set extras infor into current scope
func WithContextValues(contextValues map[string]sentrygo.Context) *Sentry {
	sentry := createSentry()
	sentry.WithContextValues(contextValues)
	return sentry
}

// Debug send debug information to sentry server
func Debug(message string) {
	createSentry().WithMessage(message).WithLevel(sentrygo.LevelDebug).sendMessage()
}

// Debugf send debug formatted message to sentry server
func Debugf(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	createSentry().WithMessage(msg).WithLevel(sentrygo.LevelDebug).sendMessage()
}

// Info send information to sentry server
func Info(message string) {
	createSentry().WithMessage(message).WithLevel(sentrygo.LevelInfo).sendMessage()
}

// Infof send formatted message to sentry server
func Infof(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	createSentry().WithMessage(msg).WithLevel(sentrygo.LevelInfo).sendMessage()
}

// Warning send warning message to sentry server
func Warning(message string) {
	createSentry().WithMessage(message).WithLevel(sentrygo.LevelWarning).sendMessage()
}

// Warningf send formatted message to sentry server
func Warningf(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	createSentry().WithMessage(msg).WithLevel(sentrygo.LevelWarning).sendMessage()
}

// Error send error to sentry server
func Error(err error) {
	createSentry().WithError(err).WithLevel(sentrygo.LevelError).sendError()
}

// Errorf send error with custom message to sentry server
func Errorf(format string, args ...interface{}) {
	err := fmt.Errorf(format, args...)
	createSentry().WithError(err).WithLevel(sentrygo.LevelError).sendError()
}

// Fatal send fatal signal to sentry server
func Fatal(err error) {
	createSentry().WithError(err).WithLevel(sentrygo.LevelFatal).sendError()
	sentrygo.Flush(FlushTime)
}

// Fatalf send fatal signal with custom message to sentry server
func Fatalf(format string, args ...interface{}) {
	err := fmt.Errorf(format, args...)
	createSentry().WithError(err).WithLevel(sentrygo.LevelFatal).sendError()
	sentrygo.Flush(FlushTime)
}
</file>

<file path="pkg/uuidv7.go">
package pkg

import "github.com/google/uuid"

func NewUUIDV7() string {
	u,_ := uuid.NewV7()
	return u.String()
}
</file>

<file path="docker-compose.yml">
version: "3"

services:
  db:
    image: postgres:17.5
    environment:
      POSTGRES_PASSWORD: ${DB_PASS}
      POSTGRES_DB: ${DB_NAME}
    ports:
      - "${DB_PORT}:5432"
    networks:
      - teqnet
    volumes:
      - teqgo-db:/var/lib/postgresql

volumes:
  teqgo-db:

networks:
  teqnet:
</file>

<file path="cmd/migrate/main.go">
package main

import (
	"e-wallet/internal/adapters/repository/postgres"
	"e-wallet/internal/config"
	"e-wallet/pkg/logger"
	"log"
	"strconv"

	migrate "github.com/rubenv/sql-migrate"
)

func main() {
	applogger, err := logger.NewAppLogger()
	defer logger.Sync(applogger)
	if err != nil {
		log.Fatalf("cannot load config: %v\n", err)
	}

	cfg, err := config.LoadConfig()
	if err != nil {
		applogger.Fatalf("cannot load config: %v\n", err)
	}

	db, err := postgres.NewConnection(postgres.Options{
		DBName:   cfg.DB.Name,
		DBUser:   cfg.DB.User,
		Password: cfg.DB.Pass,
		Host:     cfg.DB.Host,
		Port:     strconv.Itoa(cfg.DB.Port),
		SSLMode:  false,
	})
	if err != nil {
		applogger.Fatalf("cannot connecting to db: %v\n", err)
	}

	migrations := &migrate.FileMigrationSource{
		Dir: "migrations",
	}
	sqlDB, err := db.DB()
	if err != nil {
		applogger.Fatalf("cannot get underlying sql.DB: %v\n", err)
	}

	total, err := migrate.Exec(sqlDB, "postgres", migrations, migrate.Up)
	if err != nil {
		applogger.Fatalf("cannot execute migration: %v\n", err)
	}

	applogger.Infof("applied %d migrations\n", total)
}
</file>

<file path="internal/adapters/handler/http/dto/account_response.go">
package dto

import (
	"e-wallet/internal/domain/account"
)

type AccountResponse struct {
	ID               string   `json:"account_id"`
	AccountNumber    string   `json:"account_number"`
	Balance          float64  `json:"balance"`
	InterestRate     *float64 `json:"interest_rate,omitempty"`
	FixedTermMonths  *int     `json:"fixed_term_months,omitempty"`
}

type CreateAccountResponse struct {
	Account *AccountResponse `json:"account"`
}

func NewAccountResponse(acc *account.Account) *AccountResponse {
	return &AccountResponse{
		ID:              acc.ID,
		AccountNumber:   acc.AccountNumber,
		Balance:         acc.Balance,
		InterestRate:    acc.InterestRate,
		FixedTermMonths: acc.FixedTermMonths,
	}
}

func NewCreateAccountResponse(acc *account.Account) *CreateAccountResponse {
	return &CreateAccountResponse{
		Account: NewAccountResponse(acc),
	}
}
</file>

<file path="internal/adapters/handler/http/dto/create_user_request.go">
package dto

type CreateUserRequest struct {
	Username string `json:"username" validate:"required"`
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required,password"`
}
</file>

<file path="internal/adapters/handler/http/dto/validator.go">
package dto

import (
	"regexp"
	"strings"

	"github.com/go-playground/validator/v10"
)

var passwordRegex = regexp.MustCompile(`^[a-zA-Z0-9@!$%^]{12,50}$`)

func ValidatePassword(fl validator.FieldLevel) bool {
	password := fl.Field().String()

	if len(password) < 12 || len(password) > 50 {
		return false
	}

	hasLower := strings.ContainsAny(password, "abcdefghijklmnopqrstuvwxyz")
	hasUpper := strings.ContainsAny(password, "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
	hasDigit := strings.ContainsAny(password, "0123456789")
	hasSpecial := strings.ContainsAny(password, "@!$%^")

	return hasLower && hasUpper && hasDigit && hasSpecial
}

func ValidateTeam(fl validator.FieldLevel) bool {
	team := fl.Field().String()
	validTeams := []string{"Front End", "Back End", "QA", "Admin", "Brse", "Design", "Others"}
	for _, validTeam := range validTeams {
		if team == validTeam {
			return true
		}
	}
	return false
}

func RegisterCustomValidations(v *validator.Validate) {
	v.RegisterValidation("password", ValidatePassword)
	v.RegisterValidation("team", ValidateTeam)
}
</file>

<file path="internal/adapters/handler/http/auth.go">
package http

import (
	"errors"
	"os"
	"strings"
	"time"

	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	"github.com/sirupsen/logrus"
)

const (
	UserClaimKey = "UserClaimKey"
)

type Authentication struct {
	SkipperPath []string
	KeyLookup   string
	AuthScheme  string
}

func NewAuthentication(keyLookup string, authScheme string, skipperPath []string) *Authentication {
	return &Authentication{
		SkipperPath: skipperPath,
		KeyLookup:   keyLookup,
		AuthScheme:  authScheme,
	}
}

func (a *Authentication) Middleware() echo.MiddlewareFunc {
	skipper := func(c echo.Context) bool {
		return ContainFirst(a.SkipperPath, c.Path())
	}
	return middleware.KeyAuthWithConfig(middleware.KeyAuthConfig{
		Skipper:    skipper,
		KeyLookup:  a.KeyLookup,
		AuthScheme: a.AuthScheme,
		Validator:  a.ValidateAccessToken,
	})
}

func (a *Authentication) ValidateAccessToken(token string, c echo.Context) (bool, error) {

	if token == "" {
		return false, errors.New("")
	}

	claims, err := ValidateToken(token, os.Getenv("JWT_SECRET_KEY"))
	if err != nil {
		return false, err
	}

	// check expired time
	now := time.Now().Local().Unix()
	if int64(claims["exp"].(float64)) < now {
		logrus.Error("Token is expired - ValidateAccessToken")

		return false, err
	}

	// get user_id
	payload, err := DecodeToken(claims)
	if err != nil {
		logrus.Error(err)

		return false, err
	}

	if payload.UserID == "" {
		logrus.Error("Unauthorized")

		return false, errors.New("")
	}

	c.Set(UserClaimKey, payload)

	return true, nil
}

func ContainFirst(elems []string, v string) bool {
	for _, s := range elems {
		if strings.HasPrefix(v, s) {
			return true
		}
	}

	return false
}

const UserIDKey = "UserID"

func CheckUserTypeMiddleware() echo.MiddlewareFunc {
	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			userClaim, ok := c.Get(UserClaimKey).(*TokenPayload)
			if !ok {
				// return echo.NewHTTPError(http.StatusUnauthorized, "Invalid user")
			} else {
				c.Set(UserIDKey, userClaim.UserID)
			}

			return next(c)
		}
	}
}
</file>

<file path="internal/adapters/handler/http/jwt.go">
package http

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	jwt "github.com/golang-jwt/jwt/v5"
	"github.com/labstack/echo/v4"
)

const DefaultExpiredTime = 30 * 24 * time.Hour // 30 days

type TokenPayload struct {
	UserID string `json:"user_id"`
}

func CreateAccessToken(ttl time.Duration, payload TokenPayload, secretJWTKey string) (string, error) {
	token := jwt.New(jwt.SigningMethodHS256)

	now := time.Now().UTC()
	claims := token.Claims.(jwt.MapClaims)

	claims["sub"] = payload
	claims["exp"] = now.Add(ttl).Unix()

	tokenString, err := token.SignedString([]byte(secretJWTKey))

	if err != nil {
		return "", err
	}

	return tokenString, nil
}

func ValidateToken(token string, secretJWTKey string) (jwt.MapClaims, error) {
	parseToken, err := jwt.Parse(token, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, echo.NewHTTPError(http.StatusForbidden, "Unexpected signing method: %v", token.Header["alg"])
		}
		signature := []byte(secretJWTKey)
		return signature, nil
	})

	if err != nil {
		return nil, err
	}

	claims, ok := parseToken.Claims.(jwt.MapClaims)
	if ok && parseToken.Valid {
		return claims, nil
	} else {
		return nil, fmt.Errorf("invalid token")
	}
}

func DecodeToken(claims jwt.MapClaims) (*TokenPayload, error) {
	// get data from token
	sub, ok := claims["sub"]
	if !ok {
		return nil, fmt.Errorf("missing sub")
	}
	// Convert the map to JSON
	jsonData, err := json.Marshal(sub)
	if err != nil {
		return nil, err
	}
	// Convert the JSON to a struct
	var payload TokenPayload
	if err := json.Unmarshal(jsonData, &payload); err != nil {
		return nil, err
	}
	return &payload, nil
}
</file>

<file path="internal/adapters/handler/http/options.go">
package http

import "e-wallet/internal/config"


type Options func(s *Server) error

func WithConfig(cfg *config.Config) Options {
	return func(s *Server) error {
		s.Config = cfg
		return nil
	}
}
</file>

<file path="internal/adapters/repository/postgres/postgrestore.go">
package postgres

import (
	"e-wallet/internal/config"
	"fmt"
	"strconv"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

type Options struct {
	DBName   string
	DBUser   string
	Password string
	Host     string
	Port     string
	SSLMode  bool
}

func ParseFromConfig(c *config.Config) Options {
	return Options{
		DBName:   c.DB.Name,
		DBUser:   c.DB.User,
		Password: c.DB.Pass,
		Host:     c.DB.Host,
		Port:     strconv.Itoa(c.DB.Port),
		SSLMode:  c.DB.EnableSSL,
	}
}

func NewConnection(opts Options) (*gorm.DB, error) {
	sslmode := "disable"
	if opts.SSLMode {
		sslmode = "enable"
	}

	datasource := fmt.Sprintf(
		"host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
		opts.Host, opts.Port, opts.DBUser, opts.Password, opts.DBName, sslmode,
	)

	db, err := gorm.Open(postgres.Open(datasource), &gorm.Config{
		TranslateError: true,
		Logger: logger.Default.LogMode(logger.Info),
	})
	if err != nil {
		return nil, err
	}
	return db, nil
}
</file>

<file path="internal/application/account/errors.go">
package account

import "errors"

var (
	ErrLimitPaymentAccount  = errors.New("limit payment account")
	ErrLimitSavingsAccount  = errors.New("limit savings account")
	ErrInvalidTermMonths    = errors.New("invalid term months")
)
</file>

<file path=".air.toml">
# Config file for [Air](https://github.com/cosmtrek/air) in TOML format

# Working directory
# . or absolute path, please note that the directories following must be under root.
root = "."
tmp_dir = "tmp"

[build]
# Just plain old shell command. You could use `make` as well.
cmd = "go build -o ./tmp/main ./cmd/api"
# Binary file yields from `cmd`.
bin = "tmp/main"
# Customize binary, can setup environment variables when run your app.
full_bin = "./tmp/main"
# Watch these filename extensions.
include_ext = ["go", "tpl", "tmpl", "html"]
# Ignore these filename extensions or directories.
exclude_dir = ["assets", "tmp", "vendor", "ui"]
# Watch these directories if you specified.
include_dir = []
# Watch these files.
include_file = []
# Exclude files.
exclude_file = []
# Exclude specific regular expressions.
exclude_regex = ["_test\\.go"]
# Exclude unchanged files.
exclude_unchanged = true
# Follow symlink for directories
follow_symlink = true
# This log file places in your tmp_dir.
log = "air.log"
# Poll files for changes instead of using fsnotify.
poll = false
# Poll interval (defaults to the minimum interval of 500ms).
poll_interval = 500 # ms
# It's not necessary to trigger build each time file changes if it's too frequent.
delay = 0 # ms
# Stop running old binary when build errors occur.
stop_on_error = true
# Send Interrupt signal before killing process (windows does not support this feature)
send_interrupt = false
# Delay after sending Interrupt signal
kill_delay = 500 # ms
# Rerun binary or not
rerun = false
# Delay after each executions
rerun_delay = 500
# Add additional arguments when running binary (bin/full_bin). Will run './tmp/main hello world'.
args_bin = ["hello", "world"]

[log]
# Show log time
time = false
# Only show main log (silences watcher, build, runner)
main_only = false

[color]
# Customize each part's color. If no color found, use the raw app log.
main = "magenta"
watcher = "cyan"
build = "yellow"
runner = "green"

[misc]
# Delete tmp directory on exit
clean_on_exit = true

[screen]
clear_on_rebuild = true
keep_scroll = true
</file>

<file path="internal/adapters/handler/http/dto/user_response.go">
package dto

import (
	"e-wallet/internal/domain/user"
	"time"
)

type UserResponse struct {
	ID        string    `json:"id"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

type CreateUserResponse struct {
	User  *UserResponse `json:"user"`
	Token string        `json:"token"`
}

type LoginUserResponse struct {
	User  *UserResponse `json:"user"`
	Token string        `json:"token"`
}

type UpdateProfileResponse struct {
	Profile *ProfileResponse `json:"profile"`
}

type ProfileResponse struct {
	ID          string `json:"id"`
	UserID      string `json:"user_id"`
	DisplayName string `json:"display_name"`
	AvatarURL   string `json:"avatar_url"`
	PhoneNumber string `json:"phone_number"`
	NationalID  string `json:"national_id"`
	BirthYear   int    `json:"birth_year"`
	Gender      string `json:"gender"`
	Team        string `json:"team"`
}

func NewUserResponse(user *user.User) *UserResponse {
	return &UserResponse{
		ID:        user.ID,
		Username:  user.Username,
		Email:     user.Email,
		CreatedAt: user.CreatedAt,
		UpdatedAt: user.UpdatedAt,
	}
}

func NewCreateUserResponse(token string) *CreateUserResponse {
	return &CreateUserResponse{
		Token: token,
	}
}

func NewLoginUserResponse(user *user.User, token string) *LoginUserResponse {
	return &LoginUserResponse{
		User:  NewUserResponse(user),
		Token: token,
	}
}

func NewUpdateProfileResponse(profile *user.Profile) *UpdateProfileResponse {
	return &UpdateProfileResponse{
		Profile: NewProfileResponse(profile),
	}
}

func NewProfileResponse(profile *user.Profile) *ProfileResponse {
	return &ProfileResponse{
		ID:          profile.ID,
		UserID:      profile.UserID,
		DisplayName: profile.DisplayName,
		AvatarURL:   profile.AvatarURL,
		PhoneNumber: profile.PhoneNumber,
		NationalID:  profile.NationalID,
		BirthYear:   profile.BirthYear,
		Gender:      profile.Gender,
		Team:        profile.Team,
	}
}
</file>

<file path="internal/adapters/handler/http/account_handler.go">
package http

import (
	"e-wallet/internal/adapters/handler/http/dto"
	"net/http"

	"github.com/labstack/echo/v4"
)

func (s *Server) CreatePaymentAccount(c echo.Context) error {
	userID, ok := c.Get(UserIDKey).(string)
	if !ok {
		return c.JSON(http.StatusUnauthorized, map[string]string{"error": "unauthorized"})
	}

	createdAccount, err := s.AccountService.CreatePaymentAccount(c.Request().Context(), userID)
	if err != nil {
		return s.handleError(c, err, http.StatusBadRequest)
	}

	resp := dto.NewCreateAccountResponse(createdAccount)
	return c.JSON(http.StatusCreated, resp)
}

func (s *Server) CreateFlexibleSavingsAccount(c echo.Context) error {
	userID, ok := c.Get(UserIDKey).(string)
	if !ok {
		return c.JSON(http.StatusUnauthorized, map[string]string{"error": "unauthorized"})
	}

	createdAccount, err := s.AccountService.CreateFlexibleSavingsAccount(c.Request().Context(), userID)
	if err != nil {
		return s.handleError(c, err, http.StatusBadRequest)
	}

	resp := dto.NewCreateAccountResponse(createdAccount)
	return c.JSON(http.StatusCreated, resp)
}

func (s *Server) CreateFixedSavingsAccount(c echo.Context) error {
	userID, ok := c.Get(UserIDKey).(string)
	if !ok {
		return c.JSON(http.StatusUnauthorized, map[string]string{"error": "unauthorized"})
	}

	var req dto.CreateFixedSavingsRequest
	if err := c.Bind(&req); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "invalid request"})
	}

	if err := c.Validate(&req); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
	}

	createdAccount, err := s.AccountService.CreateFixedSavingsAccount(c.Request().Context(), userID, req.TermMonths)
	if err != nil {
		return s.handleError(c, err, http.StatusBadRequest)
	}

	resp := dto.NewCreateAccountResponse(createdAccount)
	return c.JSON(http.StatusCreated, resp)
}
</file>

<file path="internal/adapters/repository/postgres/profile_repository.go">
package postgres

import (
	"context"
	"errors"

	"e-wallet/internal/domain/user"
	"e-wallet/internal/ports"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

type profileRepository struct {
	db *gorm.DB
}

func NewProfileRepository(db *gorm.DB) ports.ProfileRepository {
	return &profileRepository{db: db}
}

func (r *profileRepository) Create(ctx context.Context, profile *user.Profile) (*user.Profile, error) {
	schema := &Profile{
		ID:          profile.ID,
		UserID:      profile.UserID,
		DisplayName: profile.DisplayName,
		AvatarURL:   profile.AvatarURL,
		PhoneNumber: profile.PhoneNumber,
		NationalID:  profile.NationalID,
		BirthYear:   profile.BirthYear,
		Gender:      profile.Gender,
		Team:        profile.Team,
	}

	if err := r.db.WithContext(ctx).Table(ProfilesTableName).Create(schema).Error; err != nil {
		return nil, err
	}

	return schema.ToDomain(), nil
}

func (r *profileRepository) GetByUserID(ctx context.Context, userID string) (*user.Profile, error) {
	var schema Profile
	if err := r.db.WithContext(ctx).Table(ProfilesTableName).Where("user_id = ?", userID).First(&schema).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, ErrProfileNotFound
		}
		return nil, err
	}

	return schema.ToDomain(), nil
}

func (r *profileRepository) Update(ctx context.Context, profile *user.Profile) (*user.Profile, error) {
	schema := &Profile{
		UserID:      profile.UserID,
		DisplayName: profile.DisplayName,
		AvatarURL:   profile.AvatarURL,
		PhoneNumber: profile.PhoneNumber,
		NationalID:  profile.NationalID,
		BirthYear:   profile.BirthYear,
		Gender:      profile.Gender,
		Team:        profile.Team,
	}

	if err := r.db.WithContext(ctx).Table(ProfilesTableName).Where("user_id = ?", profile.UserID).Updates(schema).Error; err != nil {
		return nil, err
	}

	return r.GetByUserID(ctx, profile.UserID)
}

func (r *profileRepository) Upsert(ctx context.Context, profile *user.Profile) (*user.Profile, error) {
	schema := &Profile{
		ID:          profile.ID,
		UserID:      profile.UserID,
		DisplayName: profile.DisplayName,
		AvatarURL:   profile.AvatarURL,
		PhoneNumber: profile.PhoneNumber,
		NationalID:  profile.NationalID,
		BirthYear:   profile.BirthYear,
		Gender:      profile.Gender,
		Team:        profile.Team,
	}

	err := r.db.WithContext(ctx).Table(ProfilesTableName).Clauses(clause.OnConflict{
		Columns: []clause.Column{{Name: "user_id"}},
		UpdateAll: true,
	}).Create(schema).Error
	if err != nil {
		return nil, err
	}

	return schema.ToDomain(), nil
}
</file>

<file path="internal/ports/account_repository.go">
package ports

import (
	"context"
	"e-wallet/internal/domain/account"
)

type AccountRepository interface {
	Create(ctx context.Context, account *account.Account) (*account.Account, error)
	GetByUserID(ctx context.Context, userID string) (*account.Account, error)
	GetByID(ctx context.Context, id string) (*account.Account, error)
	CountSavingsAccounts(ctx context.Context, userID string) (int64, error)
	GetFlexibleSavingsAccounts(ctx context.Context) ([]*account.Account, error)
	UpdateBalance(ctx context.Context, id string, balance float64) error
}
</file>

<file path="internal/ports/user_repository.go">
package ports

import (
	"context"
	"e-wallet/internal/domain/user"
)

type UserRepository interface {
	Create(ctx context.Context, user *user.User) (*user.User, error)
	GetByEmail(ctx context.Context, email string) (*user.User, error)
	GetByID(ctx context.Context, id string) (*user.User, error)
}
</file>

<file path=".gitignore">
.env
tmp
.roo
coverage
</file>

<file path=".mockery.yml">
dir: '{{.InterfaceDir}}'
structname: '{{.Mock}}{{.InterfaceName}}'
template: testify

packages:
  e-wallet/internal/ports:
    config:
      all: true
      dir: "mocks"
      pkgname: "mocks"
      filename: "ports_mocks.go"
</file>

<file path=".rooignore">
*.sum
*.env
*.yaml
*.yml
mocks
</file>

<file path="cmd/api/main.go">
package main

import (
	"fmt"
	"log"
	"net/http"

	httpserver "e-wallet/internal/adapters/handler/http"
	"e-wallet/internal/adapters/repository/postgres"
	"e-wallet/internal/application/account"
	"e-wallet/internal/application/user"
	"e-wallet/internal/config"
	"e-wallet/pkg/logger"

	sentrygo "github.com/getsentry/sentry-go"
)

func main() {
	applog, err := logger.NewAppLogger()
	if err != nil {
		log.Fatalf("cannot load config: %v\n", err)
	}
	defer logger.Sync(applog)

	cfg, err := config.LoadConfig()
	if err != nil {
		applog.Fatal(err)
	}

	err = sentrygo.Init(sentrygo.ClientOptions{
		Dsn:              cfg.SentryDSN,
		Environment:      cfg.AppEnv,
		AttachStacktrace: true,
	})
	if err != nil {
		applog.Fatalf("cannot init sentry: %v", err)
	}

	db, err := postgres.NewConnection(postgres.ParseFromConfig(cfg))
	if err != nil {
		applog.Fatal(err)
	}

	server, err := httpserver.New(httpserver.WithConfig(cfg))
	if err != nil {
		applog.Fatal(err)
	}

	server.Logger = applog
	repo := postgres.NewUserRepository(db)
	profileRepo := postgres.NewProfileRepository(db)
	accountRepo := postgres.NewAccountRepository(db)
	txRepo := postgres.NewTransactionRepository(db)
	ihRepo := postgres.NewInterestHistoryRepository(db)
	server.UserService = user.NewUserService(repo, profileRepo)
	server.AccountService = account.NewAccountService(accountRepo, repo, profileRepo, txRepo, ihRepo)

	addr := fmt.Sprintf(":%d", cfg.Port)
	applog.Info("server started!")
	applog.Fatal(http.ListenAndServe(addr, server))
}
</file>

<file path="internal/adapters/repository/postgres/schemas.go">
package postgres

import (
	"e-wallet/internal/domain/account"
	"e-wallet/internal/domain/user"
	"time"
)

const (
	UsersTableName    = "users"
	ProfilesTableName = "profiles"
	AccountsTableName = "accounts"
)

type User struct {
	ID              string
	Username        string
	Email           string
	PasswordHash    string
	IsEmailVerified bool
	CreatedAt       time.Time `gorm:"autoCreateTime"`
	UpdatedAt       time.Time `gorm:"autoUpdateTime"`
}

func (User) TableName() string {
	return "users"
}

func (u *User) ToDomain() *user.User {
	return &user.User{
		ID:              u.ID,
		Username:        u.Username,
		Email:           u.Email,
		PasswordHash:    u.PasswordHash,
		IsEmailVerified: u.IsEmailVerified,
		CreatedAt:       u.CreatedAt,
		UpdatedAt:       u.UpdatedAt,
	}
}

type Profile struct {
	ID          string
	UserID      string
	DisplayName string
	AvatarURL   string
	PhoneNumber string
	NationalID  string
	BirthYear   int
	Gender      string
	Team        string
	CreatedAt   time.Time `gorm:"autoCreateTime"`
	UpdatedAt   time.Time `gorm:"autoUpdateTime"`
}

func (p *Profile) ToDomain() *user.Profile {
	return &user.Profile{
		ID:          p.ID,
		UserID:      p.UserID,
		DisplayName: p.DisplayName,
		AvatarURL:   p.AvatarURL,
		PhoneNumber: p.PhoneNumber,
		NationalID:  p.NationalID,
		BirthYear:   p.BirthYear,
		Gender:      p.Gender,
		Team:        p.Team,
		CreatedAt:   p.CreatedAt,
		UpdatedAt:   p.UpdatedAt,
	}
}

type Account struct {
	ID              string
	UserID          string
	AccountType     string
	AccountNumber   string
	AccountName     string
	Balance         float64
	InterestRate    *float64
	FixedTermMonths *int
	CreatedAt       time.Time `gorm:"autoCreateTime"`
	UpdatedAt       time.Time `gorm:"autoUpdateTime"`
}

func (a *Account) ToDomain() *account.Account {
	return &account.Account{
		ID:              a.ID,
		UserID:          a.UserID,
		AccountType:     a.AccountType,
		AccountNumber:   a.AccountNumber,
		AccountName:     a.AccountName,
		Balance:         a.Balance,
		InterestRate:    a.InterestRate,
		FixedTermMonths: a.FixedTermMonths,
		CreatedAt:       a.CreatedAt,
		UpdatedAt:       a.UpdatedAt,
	}
}
</file>

<file path="internal/adapters/repository/postgres/user_repository.go">
package postgres

import (
	"context"
	"errors"

	"e-wallet/internal/domain/user"
	"e-wallet/internal/ports"

	"gorm.io/gorm"
)

type userRepository struct {
	db *gorm.DB
}

func NewUserRepository(db *gorm.DB) ports.UserRepository {
	return &userRepository{db: db}
}

func (r *userRepository) Create(ctx context.Context, user *user.User) (*user.User, error) {
	schema := &User{
		ID:              user.ID,
		Username:        user.Username,
		Email:           user.Email,
		PasswordHash:    user.PasswordHash,
		IsEmailVerified: user.IsEmailVerified,
	}

	if err := r.db.WithContext(ctx).Table(UsersTableName).Create(schema).Error; err != nil {
		return nil, err
	}

	return schema.ToDomain(), nil
}

func (r *userRepository) GetByEmail(ctx context.Context, email string) (*user.User, error) {
	var schema User
	if err := r.db.WithContext(ctx).Table(UsersTableName).Where("email = ?", email).First(&schema).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, ErrUserNotFound
		}
		return nil, err
	}

	return schema.ToDomain(), nil
}

func (r *userRepository) GetByID(ctx context.Context, id string) (*user.User, error) {
	var schema User
	if err := r.db.WithContext(ctx).Table(UsersTableName).Where("id = ?", id).First(&schema).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, ErrUserNotFound
		}
		return nil, err
	}

	return schema.ToDomain(), nil
}
</file>

<file path="internal/application/account/account_service_test.go">
package account

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"

	"e-wallet/internal/domain/account"
	"e-wallet/internal/domain/interest_history"
	"e-wallet/internal/domain/transaction"
	"e-wallet/internal/domain/user"
	"e-wallet/mocks"
)

func TestAccountService_CreatePaymentAccount(t *testing.T) {
	tests := []struct {
		name           string
		userID         string
		mockSetup      func(*mocks.MockAccountRepository, *mocks.MockUserRepository, *mocks.MockProfileRepository)
		expectedResult *account.Account
		expectedError  error
	}{
		{
			name:   "success - create payment account",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock no existing payment account
				accountRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(nil, errors.New("not found")).
					Once()

				// Mock account creation
				accountRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(acc *account.Account) bool {
					return acc.UserID == "user-123" &&
						acc.AccountType == account.PaymentAccountType &&
						acc.Balance == 0.0 &&
						len(acc.AccountNumber) > 0
				})).Return(&account.Account{
					ID:            "acc-123",
					UserID:        "user-123",
					AccountType:   account.PaymentAccountType,
					AccountNumber: "PAY123456789",
					Balance:       0.0,
				}, nil).Once()
			},
			expectedResult: &account.Account{
				ID:            "acc-123",
				UserID:        "user-123",
				AccountType:   account.PaymentAccountType,
				AccountNumber: "PAY123456789",
				Balance:       0.0,
			},
			expectedError: nil,
		},
		{
			name:   "error - user not found",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user not found
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(nil, errors.New("user not found")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("user not found"),
		},
		{
			name:   "error - profile not found",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile not found
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(nil, errors.New("profile not found")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("profile not found"),
		},
		{
			name:   "error - payment account already exists",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock existing payment account
				accountRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&account.Account{
						ID:          "existing-acc-123",
						UserID:      "user-123",
						AccountType: account.PaymentAccountType,
					}, nil).Once()
			},
			expectedResult: nil,
			expectedError:  ErrLimitPaymentAccount,
		},
		{
			name:   "error - account creation fails",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock no existing payment account
				accountRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(nil, errors.New("not found")).
					Once()

				// Mock account creation fails
				accountRepo.EXPECT().
					Create(mock.Anything, mock.Anything).
					Return(nil, errors.New("creation failed")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("creation failed"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create mocks
			accountRepo := mocks.NewMockAccountRepository(t)
			userRepo := mocks.NewMockUserRepository(t)
			profileRepo := mocks.NewMockProfileRepository(t)

			// Setup mocks
			tt.mockSetup(accountRepo, userRepo, profileRepo)

			// Create service
			service := NewAccountService(accountRepo, userRepo, profileRepo, nil, nil)

			// Execute
			result, err := service.CreatePaymentAccount(context.Background(), tt.userID)

			// Assert
			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
				assert.Nil(t, result)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, result)
				assert.Equal(t, tt.expectedResult.UserID, result.UserID)
				assert.Equal(t, tt.expectedResult.AccountType, result.AccountType)
				assert.Equal(t, tt.expectedResult.Balance, result.Balance)
			}
		})
	}
}

func TestAccountService_CreateFlexibleSavingsAccount(t *testing.T) {
	tests := []struct {
		name           string
		userID         string
		mockSetup      func(*mocks.MockAccountRepository, *mocks.MockUserRepository, *mocks.MockProfileRepository)
		expectedResult *account.Account
		expectedError  error
	}{
		{
			name:   "success - create flexible savings account",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock savings accounts count < 5
				accountRepo.EXPECT().
					CountSavingsAccounts(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(int64(2), nil).
					Once()

				// Mock account creation
				accountRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(acc *account.Account) bool {
					return acc.UserID == "user-123" &&
						acc.AccountType == account.FlexibleSavingsAccountType &&
						acc.Balance == 0.0 &&
						len(acc.AccountNumber) > 0
				})).Return(&account.Account{
					ID:            "acc-123",
					UserID:        "user-123",
					AccountType:   account.FlexibleSavingsAccountType,
					AccountNumber: "SAV123456789",
					Balance:       0.0,
				}, nil).Once()
			},
			expectedResult: &account.Account{
				ID:            "acc-123",
				UserID:        "user-123",
				AccountType:   account.FlexibleSavingsAccountType,
				AccountNumber: "SAV123456789",
				Balance:       0.0,
			},
			expectedError: nil,
		},
		{
			name:   "error - user not found",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user not found
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(nil, errors.New("user not found")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("user not found"),
		},
		{
			name:   "error - profile not found",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile not found
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(nil, errors.New("profile not found")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("profile not found"),
		},
		{
			name:   "error - savings account limit reached",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock savings accounts count >= 5
				accountRepo.EXPECT().
					CountSavingsAccounts(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(int64(5), nil).
					Once()
			},
			expectedResult: nil,
			expectedError:  ErrLimitSavingsAccount,
		},
		{
			name:   "error - count savings accounts fails",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock count fails
				accountRepo.EXPECT().
					CountSavingsAccounts(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(int64(0), errors.New("count failed")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("count failed"),
		},
		{
			name:   "error - account creation fails",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock savings accounts count < 5
				accountRepo.EXPECT().
					CountSavingsAccounts(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(int64(2), nil).
					Once()

				// Mock account creation fails
				accountRepo.EXPECT().
					Create(mock.Anything, mock.Anything).
					Return(nil, errors.New("creation failed")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("creation failed"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create mocks
			accountRepo := mocks.NewMockAccountRepository(t)
			userRepo := mocks.NewMockUserRepository(t)
			profileRepo := mocks.NewMockProfileRepository(t)

			// Setup mocks
			tt.mockSetup(accountRepo, userRepo, profileRepo)

			// Create service
			service := NewAccountService(accountRepo, userRepo, profileRepo, nil, nil)

			// Execute
			result, err := service.CreateFlexibleSavingsAccount(context.Background(), tt.userID)

			// Assert
			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
				assert.Nil(t, result)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, result)
				assert.Equal(t, tt.expectedResult.UserID, result.UserID)
				assert.Equal(t, tt.expectedResult.AccountType, result.AccountType)
				assert.Equal(t, tt.expectedResult.Balance, result.Balance)
			}
		})
	}
}

func TestAccountService_CreateFixedSavingsAccount(t *testing.T) {
	tests := []struct {
		name           string
		userID         string
		termMonths     int
		mockSetup      func(*mocks.MockAccountRepository, *mocks.MockUserRepository, *mocks.MockProfileRepository)
		expectedResult *account.Account
		expectedError  error
	}{
		{
			name:       "success - create fixed savings account",
			userID:     "user-123",
			termMonths: 3,
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock savings accounts count < 5
				accountRepo.EXPECT().
					CountSavingsAccounts(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(int64(2), nil).
					Once()

				// Mock account creation
				accountRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(acc *account.Account) bool {
					return acc.UserID == "user-123" &&
						acc.AccountType == account.FixedSavingsAccountType &&
						acc.Balance == 0.0 &&
						*acc.FixedTermMonths == 3 &&
						*acc.InterestRate == 1.8 &&
						len(acc.AccountNumber) > 0
				})).Return(&account.Account{
					ID:              "acc-123",
					UserID:          "user-123",
					AccountType:     account.FixedSavingsAccountType,
					AccountNumber:   "SAV123456789",
					Balance:         0.0,
					InterestRate:    func() *float64 { rate := 1.8; return &rate }(),
					FixedTermMonths: func() *int { term := 3; return &term }(),
				}, nil).Once()
			},
			expectedResult: &account.Account{
				ID:              "acc-123",
				UserID:          "user-123",
				AccountType:     account.FixedSavingsAccountType,
				AccountNumber:   "SAV123456789",
				Balance:         0.0,
				InterestRate:    func() *float64 { rate := 1.8; return &rate }(),
				FixedTermMonths: func() *int { term := 3; return &term }(),
			},
			expectedError: nil,
		},
		{
			name:       "error - user not found",
			userID:     "user-123",
			termMonths: 3,
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user not found
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(nil, errors.New("user not found")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("user not found"),
		},
		{
			name:       "error - profile not found",
			userID:     "user-123",
			termMonths: 3,
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile not found
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(nil, errors.New("profile not found")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("profile not found"),
		},
		{
			name:       "error - invalid term months",
			userID:     "user-123",
			termMonths: 2, // Invalid term
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()
			},
			expectedResult: nil,
			expectedError:  ErrInvalidTermMonths,
		},
		{
			name:       "error - savings account limit reached",
			userID:     "user-123",
			termMonths: 3,
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock savings accounts count >= 5
				accountRepo.EXPECT().
					CountSavingsAccounts(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(int64(5), nil).
					Once()
			},
			expectedResult: nil,
			expectedError:  ErrLimitSavingsAccount,
		},
		{
			name:       "error - count savings accounts fails",
			userID:     "user-123",
			termMonths: 3,
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock count fails
				accountRepo.EXPECT().
					CountSavingsAccounts(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(int64(0), errors.New("count failed")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("count failed"),
		},
		{
			name:       "error - account creation fails",
			userID:     "user-123",
			termMonths: 3,
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock savings accounts count < 5
				accountRepo.EXPECT().
					CountSavingsAccounts(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(int64(2), nil).
					Once()

				// Mock account creation fails
				accountRepo.EXPECT().
					Create(mock.Anything, mock.Anything).
					Return(nil, errors.New("creation failed")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("creation failed"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create mocks
			accountRepo := mocks.NewMockAccountRepository(t)
			userRepo := mocks.NewMockUserRepository(t)
			profileRepo := mocks.NewMockProfileRepository(t)

			// Setup mocks
			tt.mockSetup(accountRepo, userRepo, profileRepo)

			// Create service
			service := NewAccountService(accountRepo, userRepo, profileRepo, nil, nil)

			// Execute
			result, err := service.CreateFixedSavingsAccount(context.Background(), tt.userID, tt.termMonths)

			// Assert
			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
				assert.Nil(t, result)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, result)
				assert.Equal(t, tt.expectedResult.UserID, result.UserID)
				assert.Equal(t, tt.expectedResult.AccountType, result.AccountType)
				assert.Equal(t, tt.expectedResult.Balance, result.Balance)
				assert.Equal(t, *tt.expectedResult.InterestRate, *result.InterestRate)
				assert.Equal(t, *tt.expectedResult.FixedTermMonths, *result.FixedTermMonths)
			}
		})
	}
}

func TestAccountService_CalculateDailyInterest(t *testing.T) {
	tests := []struct {
		name          string
		mockSetup     func(*mocks.MockAccountRepository, *mocks.MockTransactionRepository, *mocks.MockInterestHistoryRepository)
		expectedError error
	}{
		{
			name: "success - calculate daily interest for multiple accounts",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, txRepo *mocks.MockTransactionRepository, ihRepo *mocks.MockInterestHistoryRepository) {
				// Mock GetFlexibleSavingsAccounts to return multiple accounts
				accounts := []*account.Account{
					{ID: "acc-1", UserID: "user-1", AccountType: account.FlexibleSavingsAccountType, Balance: 1000000, CreatedAt: time.Now().AddDate(0, 0, -90)},    // Older than 30 days, balance < 10M (annualRate = 0.003)
					{ID: "acc-2", UserID: "user-2", AccountType: account.FlexibleSavingsAccountType, Balance: 20000000, CreatedAt: time.Now().AddDate(0, 0, -10)}, // Newer than 30 days (annualRate = 0.008)
					{ID: "acc-3", UserID: "user-3", AccountType: account.FlexibleSavingsAccountType, Balance: 60000000, CreatedAt: time.Now().AddDate(0, 0, -90)}, // Older than 30 days, balance > 50M (annualRate = 0.005)
					{ID: "acc-4", UserID: "user-4", AccountType: account.FlexibleSavingsAccountType, Balance: 0, CreatedAt: time.Now().AddDate(0, 0, -90)},       // Zero balance (no interest)
					{ID: "acc-5", UserID: "user-5", AccountType: account.FlexibleSavingsAccountType, Balance: 30000000, CreatedAt: time.Now().AddDate(0, 0, -90)}, // Older than 30 days, 10M <= balance < 50M (annualRate = 0.004)
				}
				accountRepo.EXPECT().GetFlexibleSavingsAccounts(mock.Anything).Return(accounts, nil).Once()

				// Mock UpdateBalance for acc-1
				accountRepo.EXPECT().UpdateBalance(mock.Anything, "acc-1", mock.MatchedBy(func(balance float64) bool {
					return balance > 1000000 // Expecting interest to be added
				})).Return(nil).Once()

				// Mock Create transaction for acc-1
				txRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(tx *transaction.Transaction) bool {
					return tx.AccountID == "acc-1" && tx.TransactionType == transaction.TransactionTypeInterest
				})).Return(&transaction.Transaction{}, nil).Once()

				// Mock Create interest history for acc-1
				ihRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(ih *interest_history.InterestHistory) bool {
					return ih.AccountID == "acc-1"
				})).Return(&interest_history.InterestHistory{}, nil).Once()

				// Mock UpdateBalance for acc-2
				accountRepo.EXPECT().UpdateBalance(mock.Anything, "acc-2", mock.MatchedBy(func(balance float64) bool {
					return balance > 20000000 // Expecting interest to be added
				})).Return(nil).Once()

				// Mock Create transaction for acc-2
				txRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(tx *transaction.Transaction) bool {
					return tx.AccountID == "acc-2" && tx.TransactionType == transaction.TransactionTypeInterest
				})).Return(&transaction.Transaction{}, nil).Once()

				// Mock Create interest history for acc-2
				ihRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(ih *interest_history.InterestHistory) bool {
					return ih.AccountID == "acc-2"
				})).Return(&interest_history.InterestHistory{}, nil).Once()

				// Mock UpdateBalance for acc-3
				accountRepo.EXPECT().UpdateBalance(mock.Anything, "acc-3", mock.MatchedBy(func(balance float64) bool {
					return balance > 60000000 // Expecting interest to be added
				})).Return(nil).Once()

				// Mock Create transaction for acc-3
				txRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(tx *transaction.Transaction) bool {
					return tx.AccountID == "acc-3" && tx.TransactionType == transaction.TransactionTypeInterest
				})).Return(&transaction.Transaction{}, nil).Once()

				// Mock Create interest history for acc-3
				ihRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(ih *interest_history.InterestHistory) bool {
					return ih.AccountID == "acc-3"
				})).Return(&interest_history.InterestHistory{}, nil).Once()

				// acc-4 (zero balance) should not trigger UpdateBalance, Create, Create

				// Mock UpdateBalance for acc-5
				accountRepo.EXPECT().UpdateBalance(mock.Anything, "acc-5", mock.MatchedBy(func(balance float64) bool {
					return balance > 30000000 // Expecting interest to be added
				})).Return(nil).Once()

				// Mock Create transaction for acc-5
				txRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(tx *transaction.Transaction) bool {
					return tx.AccountID == "acc-5" && tx.TransactionType == transaction.TransactionTypeInterest
				})).Return(&transaction.Transaction{}, nil).Once()

				// Mock Create interest history for acc-5
				ihRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(ih *interest_history.InterestHistory) bool {
					return ih.AccountID == "acc-5"
				})).Return(&interest_history.InterestHistory{}, nil).Once()
			},
			expectedError: nil,
		},
		{
			name: "error - GetFlexibleSavingsAccounts fails",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, txRepo *mocks.MockTransactionRepository, ihRepo *mocks.MockInterestHistoryRepository) {
				accountRepo.EXPECT().GetFlexibleSavingsAccounts(mock.Anything).Return(nil, errors.New("db error")).Once()
			},
			expectedError: errors.New("db error"),
		},
		{
			name: "error - UpdateBalance fails",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, txRepo *mocks.MockTransactionRepository, ihRepo *mocks.MockInterestHistoryRepository) {
				accounts := []*account.Account{
					{ID: "acc-1", UserID: "user-1", AccountType: account.FlexibleSavingsAccountType, Balance: 1000000, CreatedAt: time.Now().AddDate(0, 0, -60)},
				}
				accountRepo.EXPECT().GetFlexibleSavingsAccounts(mock.Anything).Return(accounts, nil).Once()
				accountRepo.EXPECT().UpdateBalance(mock.Anything, "acc-1", mock.AnythingOfType("float64")).Return(errors.New("update error")).Once()
			},
			expectedError: errors.New("update error"),
		},
		{
			name: "error - Create transaction fails",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, txRepo *mocks.MockTransactionRepository, ihRepo *mocks.MockInterestHistoryRepository) {
				accounts := []*account.Account{
					{ID: "acc-1", UserID: "user-1", AccountType: account.FlexibleSavingsAccountType, Balance: 1000000, CreatedAt: time.Now().AddDate(0, 0, -60)},
				}
				accountRepo.EXPECT().GetFlexibleSavingsAccounts(mock.Anything).Return(accounts, nil).Once()
				accountRepo.EXPECT().UpdateBalance(mock.Anything, "acc-1", mock.AnythingOfType("float64")).Return(nil).Once()
				txRepo.EXPECT().Create(mock.Anything, mock.AnythingOfType("*transaction.Transaction")).Return(nil, errors.New("tx error")).Once()
			},
			expectedError: errors.New("tx error"),
		},
		{
			name: "error - Create interest history fails",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, txRepo *mocks.MockTransactionRepository, ihRepo *mocks.MockInterestHistoryRepository) {
				accounts := []*account.Account{
					{ID: "acc-1", UserID: "user-1", AccountType: account.FlexibleSavingsAccountType, Balance: 1000000, CreatedAt: time.Now().AddDate(0, 0, -60)},
				}
				accountRepo.EXPECT().GetFlexibleSavingsAccounts(mock.Anything).Return(accounts, nil).Once()
				accountRepo.EXPECT().UpdateBalance(mock.Anything, "acc-1", mock.AnythingOfType("float64")).Return(nil).Once()
				txRepo.EXPECT().Create(mock.Anything, mock.AnythingOfType("*transaction.Transaction")).Return(&transaction.Transaction{}, nil).Once()
				ihRepo.EXPECT().Create(mock.Anything, mock.AnythingOfType("*interest_history.InterestHistory")).Return(nil, errors.New("ih error")).Once()
			},
			expectedError: errors.New("ih error"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create mocks
			accountRepo := mocks.NewMockAccountRepository(t)
			txRepo := mocks.NewMockTransactionRepository(t)
			ihRepo := mocks.NewMockInterestHistoryRepository(t)

			// Setup mocks
			tt.mockSetup(accountRepo, txRepo, ihRepo)

			// Create service
			service := NewAccountService(accountRepo, nil, nil, txRepo, ihRepo)

			// Execute
			err := service.CalculateDailyInterest(context.Background())

			// Assert
			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
			} else {
				assert.NoError(t, err)
			}
		})
	}
}
</file>

<file path="internal/application/user/user_service.go">
package user

import (
	"context"
	"e-wallet/internal/domain/user"
	"e-wallet/internal/ports"
	"e-wallet/pkg"
)

type userService struct {
	repo            ports.UserRepository
	profileRepo     ports.ProfileRepository
}

func NewUserService(repo ports.UserRepository, profileRepo ports.ProfileRepository) ports.UserService {
	return &userService{repo: repo, profileRepo: profileRepo}
}

func (s *userService) CreateUser(ctx context.Context, req *user.CreateUserRequest) (*user.User, error) {
	hashedPassword, err := user.HashPassword(req.Password)
	if err != nil {
		return nil, err
	}

	u := &user.User{
		ID:           pkg.NewUUIDV7(),
		Username:     req.Username,
		Email:        req.Email,
		PasswordHash: hashedPassword,
	}

	return s.repo.Create(ctx, u)
}

func (s *userService) LoginUser(ctx context.Context, req *user.LoginUserRequest) (*user.User, error) {
	u, err := s.repo.GetByEmail(ctx, req.Email)
	if err != nil {
		return nil, err
	}

	if err := user.CheckPassword(u.PasswordHash, req.Password); err != nil {
		return nil, err
	}

	return u, nil
}

func (s *userService) UpdateProfile(ctx context.Context, userID string, req *user.UpdateProfileRequest) (*user.Profile, error) {
	// Upsert profile
	profile := &user.Profile{
		ID:          pkg.NewUUIDV7(),
		UserID:      userID,
		DisplayName: req.DisplayName,
		AvatarURL:   req.AvatarURL,
		PhoneNumber: req.PhoneNumber,
		NationalID:  req.NationalID,
		BirthYear:   req.BirthYear,
		Gender:      req.Gender,
		Team:        req.Team,
	}

	p, err := s.profileRepo.Upsert(ctx, profile)
	if err != nil {
		return nil, err
	}

	return p, nil
}

func (s *userService) GetProfile(ctx context.Context, userID string) (*user.Profile, error) {
	return s.profileRepo.GetByUserID(ctx, userID)
}
</file>

<file path="internal/domain/user/user.go">
package user

import (
	"time"

	"golang.org/x/crypto/bcrypt"
)

type User struct {
	ID               string    `json:"id" gorm:"type:uuid;default:gen_random_uuid()"`
	Username         string    `json:"username" gorm:"uniqueIndex;not null"`
	Email            string    `json:"email" gorm:"uniqueIndex;not null"`
	PasswordHash     string    `json:"-" gorm:"not null"`
	IsEmailVerified  bool      `json:"is_email_verified" gorm:"default:false"`
	CreatedAt        time.Time `json:"created_at"`
	UpdatedAt        time.Time `json:"updated_at"`
}

type CreateUserRequest struct {
	Username string `json:"username"`
	Email    string `json:"email"`
	Password string `json:"password"`
}

type LoginUserRequest struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

func HashPassword(password string) (string, error) {
	hashed, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return "", err
	}
	return string(hashed), nil
}

func CheckPassword(hashedPassword, password string) error {
	return bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
}
</file>

<file path="go.mod">
module e-wallet

go 1.25

require (
	github.com/getsentry/sentry-go v0.35.3
	github.com/getsentry/sentry-go/echo v0.35.3
	github.com/go-playground/validator/v10 v10.27.0
	github.com/golang-jwt/jwt/v5 v5.3.0
	github.com/google/uuid v1.6.0
	github.com/joho/godotenv v1.5.1
	github.com/kelseyhightower/envconfig v1.4.0
	github.com/labstack/echo/v4 v4.12.0
	github.com/rubenv/sql-migrate v1.8.0
	github.com/sirupsen/logrus v1.9.3
	github.com/stretchr/testify v1.11.1
	go.uber.org/zap v1.27.0
	golang.org/x/crypto v0.37.0
	gorm.io/driver/postgres v1.5.7
	gorm.io/gorm v1.25.10
)

require (
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/gabriel-vasile/mimetype v1.4.8 // indirect
	github.com/go-gorp/gorp/v3 v3.1.0 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/golang-jwt/jwt v3.2.2+incompatible // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a // indirect
	github.com/jackc/pgx/v5 v5.4.3 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/labstack/gommon v0.4.2 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/stretchr/objx v0.5.2 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasttemplate v1.2.2 // indirect
	go.uber.org/multierr v1.10.0 // indirect
	golang.org/x/net v0.34.0 // indirect
	golang.org/x/sys v0.32.0 // indirect
	golang.org/x/text v0.24.0 // indirect
	golang.org/x/time v0.5.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)
</file>

<file path="Makefile">
run:
	air -c .air.toml

worker:
	go run ./cmd/worker

local-db:
	docker-compose --env-file ./.env -f docker-compose.yml down
	docker-compose --env-file ./.env -f docker-compose.yml up -d

db/migrate:
	go run ./cmd/migrate

unit-test:
	@mkdir coverage || true
	-go test -p 20 -v -coverprofile=coverage/coverage.txt.tmp -count=1 ./internal/...
	@cat coverage/coverage.txt.tmp | grep -v "mock_" > coverage/coverage.txt
	@go tool cover -func=coverage/coverage.txt
	@go tool cover -html=coverage/coverage.txt -o coverage/index-application.html
</file>

<file path="internal/adapters/handler/http/user_handler.go">
package http

import (
	"e-wallet/internal/adapters/handler/http/dto"
	"e-wallet/internal/domain/user"
	"net/http"

	"github.com/labstack/echo/v4"
)

func (s *Server) CreateUser(c echo.Context) error {
	var req dto.CreateUserRequest
	if err := c.Bind(&req); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "invalid request"})
	}

	if err := c.Validate(&req); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
	}

	createdUser, err := s.UserService.CreateUser(c.Request().Context(), &user.CreateUserRequest{
		Username: req.Username,
		Email:    req.Email,
		Password: req.Password,
	})
	if err != nil {
		return s.handleError(c, err, http.StatusInternalServerError)
	}

	payload := TokenPayload{UserID: createdUser.ID}
	token, err := CreateAccessToken(DefaultExpiredTime, payload, s.Config.JWTSecret)
	if err != nil {
		return s.handleError(c, err, http.StatusInternalServerError)
	}

	resp := dto.NewCreateUserResponse(token)
	return c.JSON(http.StatusCreated, resp)
}

func (s *Server) LoginUser(c echo.Context) error {
	var req dto.LoginUserRequest
	if err := c.Bind(&req); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "invalid request"})
	}

	if err := c.Validate(&req); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
	}

	user, err := s.UserService.LoginUser(c.Request().Context(), &user.LoginUserRequest{
		Email:    req.Email,
		Password: req.Password,
	})
	if err != nil {
		return s.handleError(c, err, http.StatusUnauthorized)
	}

	payload := TokenPayload{UserID: user.ID}
	token, err := CreateAccessToken(DefaultExpiredTime, payload, s.Config.JWTSecret)
	if err != nil {
		return s.handleError(c, err, http.StatusInternalServerError)
	}

	resp := dto.NewLoginUserResponse(user, token)
	return c.JSON(http.StatusOK, resp)
}

func (s *Server) UpdateProfile(c echo.Context) error {
	userID, ok := c.Get(UserIDKey).(string)
	if !ok {
		return c.JSON(http.StatusUnauthorized, map[string]string{"error": "unauthorized"})
	}

	var req dto.UpdateProfileRequest
	if err := c.Bind(&req); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "invalid request"})
	}

	if err := c.Validate(&req); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
	}

	updatedProfile, err := s.UserService.UpdateProfile(c.Request().Context(), userID, &user.UpdateProfileRequest{
		Username:    req.Username,
		DisplayName: req.DisplayName,
		AvatarURL:   req.AvatarURL,
		PhoneNumber: req.PhoneNumber,
		NationalID:  req.NationalID,
		BirthYear:   req.BirthYear,
		Gender:      req.Gender,
		Team:        req.Team,
	})
	if err != nil {
		return s.handleError(c, err, http.StatusInternalServerError)
	}

	resp := dto.NewUpdateProfileResponse(updatedProfile)
	return c.JSON(http.StatusOK, resp)
}
</file>

<file path="internal/adapters/repository/postgres/account_repository.go">
package postgres

import (
	"context"
	"errors"

	"e-wallet/internal/domain/account"
	"e-wallet/internal/ports"

	"gorm.io/gorm"
)

type accountRepository struct {
	db *gorm.DB
}

func NewAccountRepository(db *gorm.DB) ports.AccountRepository {
	return &accountRepository{db: db}
}

func (r *accountRepository) Create(ctx context.Context, account *account.Account) (*account.Account, error) {
	schema := Account{
		ID:              account.ID,
		UserID:          account.UserID,
		AccountType:     account.AccountType,
		AccountNumber:   account.AccountNumber,
		AccountName:     account.AccountName,
		Balance:         account.Balance,
		InterestRate:    account.InterestRate,
		FixedTermMonths: account.FixedTermMonths,
	}

	if err := r.db.WithContext(ctx).Table(AccountsTableName).Create(&schema).Error; err != nil {
		return nil, err
	}

	return schema.ToDomain(), nil
}

func (r *accountRepository) GetByUserID(ctx context.Context, userID string) (*account.Account, error) {
	var schema Account
	if err := r.db.WithContext(ctx).Table(AccountsTableName).Where("user_id = ?", userID).First(&schema).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, ErrAccountNotFound
		}
		return nil, err
	}

	return schema.ToDomain(), nil
}

func (r *accountRepository) GetByID(ctx context.Context, id string) (*account.Account, error) {
	var schema Account
	if err := r.db.WithContext(ctx).Table(AccountsTableName).Where("id = ?", id).First(&schema).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, ErrAccountNotFound
		}
		return nil, err
	}

	return schema.ToDomain(), nil
}

func (r *accountRepository) CountSavingsAccounts(ctx context.Context, userID string) (int64, error) {
	var count int64
	if err := r.db.WithContext(ctx).Table(AccountsTableName).Where("user_id = ? AND account_type LIKE ?", userID, "savings_%").Count(&count).Error; err != nil {
		return 0, err
	}
	return count, nil
}

func (r *accountRepository) GetFlexibleSavingsAccounts(ctx context.Context) ([]*account.Account, error) {
	var schemas []Account
	if err := r.db.WithContext(ctx).Table(AccountsTableName).Where("account_type = ?", account.FlexibleSavingsAccountType).Find(&schemas).Error; err != nil {
		return nil, err
	}

	accounts := make([]*account.Account, len(schemas))
	for i, schema := range schemas {
		accounts[i] = schema.ToDomain()
	}
	return accounts, nil
}

func (r *accountRepository) UpdateBalance(ctx context.Context, id string, balance float64) error {
	return r.db.WithContext(ctx).Table(AccountsTableName).Where("id = ?", id).Update("balance", balance).Error
}
</file>

<file path="internal/application/account/account_service.go">
package account

import (
	"context"
	"fmt"
	"time"

	"e-wallet/internal/domain/account"
	"e-wallet/internal/domain/interest_history"
	"e-wallet/internal/domain/transaction"
	"e-wallet/internal/ports"
	"e-wallet/pkg"
)

type accountService struct {
	repo        ports.AccountRepository
	userRepo    ports.UserRepository
	profileRepo ports.ProfileRepository
	txRepo      ports.TransactionRepository
	ihRepo      ports.InterestHistoryRepository
}

func NewAccountService(repo ports.AccountRepository, userRepo ports.UserRepository, profileRepo ports.ProfileRepository, txRepo ports.TransactionRepository, ihRepo ports.InterestHistoryRepository) ports.AccountService {
	return &accountService{repo: repo, userRepo: userRepo, profileRepo: profileRepo, txRepo: txRepo, ihRepo: ihRepo}
}

func (s *accountService) CreatePaymentAccount(ctx context.Context, userID string) (*account.Account, error) {
	// Check if user exists
	_, err := s.userRepo.GetByID(ctx, userID)
	if err != nil {
		return nil, err
	}

	// Check profile status (assume verified if profile exists)
	_, err = s.profileRepo.GetByUserID(ctx, userID)
	if err != nil {
		return nil, err
	}

	// Check if user already has a payment account
	_, err = s.repo.GetByUserID(ctx, userID)
	if err == nil {
		return nil, ErrLimitPaymentAccount
	}

	// Generate account number (simple: PAY + uuid prefix)
	accountNumber := fmt.Sprintf("PAY%d", time.Now().UnixNano())

	// Create account
	acc := &account.Account{
		ID:            pkg.NewUUIDV7(),
		UserID:        userID,
		AccountType:   account.PaymentAccountType,
		AccountNumber: accountNumber,
		Balance:       0.0,
	}

	return s.repo.Create(ctx, acc)
}

func (s *accountService) CalculateDailyInterest(ctx context.Context) error {
	// Get yesterday's date
	yesterday := time.Now().AddDate(0, 0, -1)

	// Get all flexible savings accounts
	accounts, err := s.repo.GetFlexibleSavingsAccounts(ctx)
	if err != nil {
		return err
	}

	for _, acc := range accounts {
		// Calculate interest
		interestAmount := s.calculateInterest(acc.Balance, acc.CreatedAt)

		if interestAmount == 0 {
			continue
		}

		// Update balance
		newBalance := acc.Balance + interestAmount
		if err := s.repo.UpdateBalance(ctx, acc.ID, newBalance); err != nil {
			return err
		}

		// Create transaction
		tx := &transaction.Transaction{
			ID:              pkg.NewUUIDV7(),
			AccountID:       acc.ID,
			TransactionType: transaction.TransactionTypeInterest,
			Amount:          interestAmount,
			Status:          transaction.TransactionStatusSuccess,
			BalanceAfter:    newBalance,
		}
		if _, err := s.txRepo.Create(ctx, tx); err != nil {
			return err
		}

		// Create interest history
		ih := &interest_history.InterestHistory{
			ID:             pkg.NewUUIDV7(),
			AccountID:      acc.ID,
			Date:           yesterday,
			InterestAmount: interestAmount,
		}
		if _, err := s.ihRepo.Create(ctx, ih); err != nil {
			return err
		}
	}

	return nil
}

func (s *accountService) calculateInterest(balance float64, date time.Time) float64 {
	var annualRate float64
	switch {
	case time.Since(date) < 30*24*time.Hour:
		annualRate = 0.008
	case balance < 10000000: // under 10M
		annualRate = 0.003
	case balance < 50000000: // 10-50M
		annualRate = 0.004
	default: // over 50M
		annualRate = 0.005
	}

	dailyRate := annualRate / 365
	return balance * dailyRate
}

func (s *accountService) CreateFlexibleSavingsAccount(ctx context.Context, userID string) (*account.Account, error) {
	// Check if user exists
	_, err := s.userRepo.GetByID(ctx, userID)
	if err != nil {
		return nil, err
	}

	// Check profile status (assume verified if profile exists)
	_, err = s.profileRepo.GetByUserID(ctx, userID)
	if err != nil {
		return nil, err
	}

	// Check limit savings accounts
	count, err := s.repo.CountSavingsAccounts(ctx, userID)
	if err != nil {
		return nil, err
	}
	if count >= 5 {
		return nil, ErrLimitSavingsAccount
	}

	// Generate account number
	accountNumber := fmt.Sprintf("SAV%d", time.Now().UnixNano())

	// Create account
	acc := &account.Account{
		ID:            pkg.NewUUIDV7(),
		UserID:        userID,
		AccountType:   account.FlexibleSavingsAccountType,
		AccountNumber: accountNumber,
		Balance:       0.0,
	}

	return s.repo.Create(ctx, acc)
}

func (s *accountService) CreateFixedSavingsAccount(ctx context.Context, userID string, termMonths int) (*account.Account, error) {
	// Check if user exists
	_, err := s.userRepo.GetByID(ctx, userID)
	if err != nil {
		return nil, err
	}

	// Check profile status (assume verified if profile exists)
	_, err = s.profileRepo.GetByUserID(ctx, userID)
	if err != nil {
		return nil, err
	}

	// Validate term months
	validTerms := map[int]float64{
		1:  0.6,
		3:  1.8,
		6:  3.6,
		8:  4.8,
		12: 7.2,
	}
	interestRate, ok := validTerms[termMonths]
	if !ok {
		return nil, ErrInvalidTermMonths
	}

	// Check limit savings accounts
	count, err := s.repo.CountSavingsAccounts(ctx, userID)
	if err != nil {
		return nil, err
	}
	if count >= 5 {
		return nil, ErrLimitSavingsAccount
	}

	// Generate account number
	accountNumber := fmt.Sprintf("SAV%d", time.Now().UnixNano())

	// Create account
	acc := &account.Account{
		ID:              pkg.NewUUIDV7(),
		UserID:          userID,
		AccountType:     account.FixedSavingsAccountType,
		AccountNumber:   accountNumber,
		Balance:         0.0,
		InterestRate:    &interestRate,
		FixedTermMonths: &termMonths,
	}

	return s.repo.Create(ctx, acc)
}
</file>

<file path="internal/domain/account/account.go">
package account

import (
	"time"
)

const (
	PaymentAccountType        = "payment"
	FixedSavingsAccountType   = "savings_fixed"
	FlexibleSavingsAccountType = "savings_flexible"
)

type Account struct {
	ID               string    `json:"id" gorm:"type:uuid;default:gen_random_uuid()"`
	UserID           string    `json:"user_id" gorm:"not null"`
	AccountType      string    `json:"account_type" gorm:"not null"`
	AccountNumber    string    `json:"account_number" gorm:"unique;not null"`
	AccountName      string    `json:"account_name"`
	Balance          float64   `json:"balance" gorm:"type:numeric(18,2);default:0.00"`
	InterestRate     *float64  `json:"interest_rate" gorm:"type:numeric(5,2)"`
	FixedTermMonths  *int      `json:"fixed_term_months"`
	CreatedAt        time.Time `json:"created_at"`
	UpdatedAt        time.Time `json:"updated_at"`
}

type CreateAccountRequest struct {
	UserID      string `json:"user_id"`
	AccountType string `json:"account_type"`
}
</file>

<file path="internal/adapters/handler/http/server.go">
package http

import (
	"e-wallet/internal/adapters/handler/http/dto"
	"e-wallet/internal/config"
	"e-wallet/internal/ports"
	"e-wallet/pkg/logger"
	"e-wallet/pkg/sentry"
	"net/http"
	"strings"

	sentryecho "github.com/getsentry/sentry-go/echo"
	"github.com/go-playground/validator/v10"
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	"go.uber.org/zap"
)

type Server struct {
	Router *echo.Echo
	Config *config.Config
	Logger *zap.SugaredLogger

	// service layers
	UserService    ports.UserService
	AccountService ports.AccountService
}

type CustomValidator struct {
	validator *validator.Validate
}

func (cv *CustomValidator) Validate(i interface{}) error {
	return cv.validator.Struct(i)
}

func New(options ...Options) (*Server, error) {
	s := Server{
		Router: echo.New(),
		Config: config.Empty,
		Logger: logger.NOOPLogger,
	}

	v := validator.New()
	dto.RegisterCustomValidations(v)
	s.Router.Validator = &CustomValidator{validator: v}

	for _, fn := range options {
		if err := fn(&s); err != nil {
			return nil, err
		}
	}

	s.RegisterGlobalMiddlewares()
	s.RegisterAuthMiddlewares()
	s.RegisterUserClaimsMiddlewares()
	s.RegisterRoute()

	s.RegisterHealthCheck(s.Router.Group(""))

	return &s, nil
}

func (s *Server) RegisterGlobalMiddlewares() {
	s.Router.Use(middleware.Recover())
	s.Router.Use(middleware.Secure())
	s.Router.Use(middleware.RequestID())
	s.Router.Use(middleware.Gzip())
	s.Router.Use(sentryecho.New(sentryecho.Options{Repanic: true}))

	// CORS
	if s.Config.AllowOrigins != "" {
		aos := strings.Split(s.Config.AllowOrigins, ",")
		s.Router.Use(middleware.CORSWithConfig(middleware.CORSConfig{
			AllowOrigins: aos,
		}))
	}
}

func (s *Server) RegisterAuthMiddlewares() {
	skipperPath := []string{
		"/healthz",
		"/api/auth",
	}
	s.Router.Use(NewAuthentication("header:Authorization", "Bearer", skipperPath).Middleware())
}

func (s *Server) RegisterUserClaimsMiddlewares() {
	s.Router.Use(CheckUserTypeMiddleware())
}

func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	s.Router.ServeHTTP(w, r)
}

func (s *Server) RegisterHealthCheck(router *echo.Group) {
	router.GET("/healthz", func(c echo.Context) error {
		return c.JSON(http.StatusOK, map[string]string{
			"status":  http.StatusText(http.StatusOK),
			"message": "Service is up and running",
		})
	})
}

func (s *Server) handleError(c echo.Context, err error, status int) error {
	s.Logger.Errorw(
		err.Error(),
		zap.String("request_id", s.requestID(c)),
	)

	if status >= http.StatusInternalServerError {
		sentry.WithContext(c).Error(err)
	}

	return c.JSON(status, map[string]string{
		"message": http.StatusText(status),
	})
}

func (s *Server) requestID(c echo.Context) string {
	return c.Response().Header().Get(echo.HeaderXRequestID)
}

func (s *Server) RegisterRoute() {
	apiGroup := s.Router.Group("/api")
	// auth
	apiGroup.POST("/auth/register", s.CreateUser)
	apiGroup.POST("/auth/login", s.LoginUser)
	// user
	apiGroup.PUT("/user/profile", s.UpdateProfile)
	// accounts
	apiGroup.POST("/accounts/payment", s.CreatePaymentAccount)
	apiGroup.POST("/accounts/savings/fixed", s.CreateFixedSavingsAccount)
	apiGroup.POST("/accounts/savings/flexible", s.CreateFlexibleSavingsAccount)
}
</file>

</files>
