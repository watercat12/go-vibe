This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
account/
  account_service_test.go
  account_service.go
  errors.go
user/
  user_service_test.go
  user_service.go
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="account/account_service_test.go">
package account

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"

	"e-wallet/internal/domain/account"
	"e-wallet/internal/domain/interest_history"
	"e-wallet/internal/domain/transaction"
	"e-wallet/internal/domain/user"
	"e-wallet/mocks"
)

func TestAccountService_CreatePaymentAccount(t *testing.T) {
	tests := []struct {
		name           string
		userID         string
		mockSetup      func(*mocks.MockAccountRepository, *mocks.MockUserRepository, *mocks.MockProfileRepository)
		expectedResult *account.Account
		expectedError  error
	}{
		{
			name:   "success - create payment account",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock no existing payment account
				accountRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(nil, errors.New("not found")).
					Once()

				// Mock account creation
				accountRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(acc *account.Account) bool {
					return acc.UserID == "user-123" &&
						acc.AccountType == account.PaymentAccountType &&
						acc.Balance == 0.0 &&
						len(acc.AccountNumber) > 0
				})).Return(&account.Account{
					ID:            "acc-123",
					UserID:        "user-123",
					AccountType:   account.PaymentAccountType,
					AccountNumber: "PAY123456789",
					Balance:       0.0,
				}, nil).Once()
			},
			expectedResult: &account.Account{
				ID:            "acc-123",
				UserID:        "user-123",
				AccountType:   account.PaymentAccountType,
				AccountNumber: "PAY123456789",
				Balance:       0.0,
			},
			expectedError: nil,
		},
		{
			name:   "error - user not found",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user not found
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(nil, errors.New("user not found")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("user not found"),
		},
		{
			name:   "error - profile not found",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile not found
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(nil, errors.New("profile not found")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("profile not found"),
		},
		{
			name:   "error - payment account already exists",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock existing payment account
				accountRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&account.Account{
						ID:          "existing-acc-123",
						UserID:      "user-123",
						AccountType: account.PaymentAccountType,
					}, nil).Once()
			},
			expectedResult: nil,
			expectedError:  ErrLimitPaymentAccount,
		},
		{
			name:   "error - account creation fails",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock no existing payment account
				accountRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(nil, errors.New("not found")).
					Once()

				// Mock account creation fails
				accountRepo.EXPECT().
					Create(mock.Anything, mock.Anything).
					Return(nil, errors.New("creation failed")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("creation failed"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create mocks
			accountRepo := mocks.NewMockAccountRepository(t)
			userRepo := mocks.NewMockUserRepository(t)
			profileRepo := mocks.NewMockProfileRepository(t)

			// Setup mocks
			tt.mockSetup(accountRepo, userRepo, profileRepo)

			// Create service
			service := NewAccountService(accountRepo, userRepo, profileRepo, nil, nil)

			// Execute
			result, err := service.CreatePaymentAccount(context.Background(), tt.userID)

			// Assert
			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
				assert.Nil(t, result)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, result)
				assert.Equal(t, tt.expectedResult.UserID, result.UserID)
				assert.Equal(t, tt.expectedResult.AccountType, result.AccountType)
				assert.Equal(t, tt.expectedResult.Balance, result.Balance)
			}
		})
	}
}

func TestAccountService_CreateFlexibleSavingsAccount(t *testing.T) {
	tests := []struct {
		name           string
		userID         string
		mockSetup      func(*mocks.MockAccountRepository, *mocks.MockUserRepository, *mocks.MockProfileRepository)
		expectedResult *account.Account
		expectedError  error
	}{
		{
			name:   "success - create flexible savings account",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock savings accounts count < 5
				accountRepo.EXPECT().
					CountSavingsAccounts(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(int64(2), nil).
					Once()

				// Mock account creation
				accountRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(acc *account.Account) bool {
					return acc.UserID == "user-123" &&
						acc.AccountType == account.FlexibleSavingsAccountType &&
						acc.Balance == 0.0 &&
						len(acc.AccountNumber) > 0
				})).Return(&account.Account{
					ID:            "acc-123",
					UserID:        "user-123",
					AccountType:   account.FlexibleSavingsAccountType,
					AccountNumber: "SAV123456789",
					Balance:       0.0,
				}, nil).Once()
			},
			expectedResult: &account.Account{
				ID:            "acc-123",
				UserID:        "user-123",
				AccountType:   account.FlexibleSavingsAccountType,
				AccountNumber: "SAV123456789",
				Balance:       0.0,
			},
			expectedError: nil,
		},
		{
			name:   "error - user not found",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user not found
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(nil, errors.New("user not found")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("user not found"),
		},
		{
			name:   "error - profile not found",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile not found
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(nil, errors.New("profile not found")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("profile not found"),
		},
		{
			name:   "error - savings account limit reached",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock savings accounts count >= 5
				accountRepo.EXPECT().
					CountSavingsAccounts(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(int64(5), nil).
					Once()
			},
			expectedResult: nil,
			expectedError:  ErrLimitSavingsAccount,
		},
		{
			name:   "error - count savings accounts fails",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock count fails
				accountRepo.EXPECT().
					CountSavingsAccounts(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(int64(0), errors.New("count failed")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("count failed"),
		},
		{
			name:   "error - account creation fails",
			userID: "user-123",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock savings accounts count < 5
				accountRepo.EXPECT().
					CountSavingsAccounts(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(int64(2), nil).
					Once()

				// Mock account creation fails
				accountRepo.EXPECT().
					Create(mock.Anything, mock.Anything).
					Return(nil, errors.New("creation failed")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("creation failed"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create mocks
			accountRepo := mocks.NewMockAccountRepository(t)
			userRepo := mocks.NewMockUserRepository(t)
			profileRepo := mocks.NewMockProfileRepository(t)

			// Setup mocks
			tt.mockSetup(accountRepo, userRepo, profileRepo)

			// Create service
			service := NewAccountService(accountRepo, userRepo, profileRepo, nil, nil)

			// Execute
			result, err := service.CreateFlexibleSavingsAccount(context.Background(), tt.userID)

			// Assert
			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
				assert.Nil(t, result)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, result)
				assert.Equal(t, tt.expectedResult.UserID, result.UserID)
				assert.Equal(t, tt.expectedResult.AccountType, result.AccountType)
				assert.Equal(t, tt.expectedResult.Balance, result.Balance)
			}
		})
	}
}

func TestAccountService_CreateFixedSavingsAccount(t *testing.T) {
	tests := []struct {
		name           string
		userID         string
		termMonths     int
		mockSetup      func(*mocks.MockAccountRepository, *mocks.MockUserRepository, *mocks.MockProfileRepository)
		expectedResult *account.Account
		expectedError  error
	}{
		{
			name:       "success - create fixed savings account",
			userID:     "user-123",
			termMonths: 3,
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock savings accounts count < 5
				accountRepo.EXPECT().
					CountSavingsAccounts(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(int64(2), nil).
					Once()

				// Mock account creation
				accountRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(acc *account.Account) bool {
					return acc.UserID == "user-123" &&
						acc.AccountType == account.FixedSavingsAccountType &&
						acc.Balance == 0.0 &&
						*acc.FixedTermMonths == 3 &&
						*acc.InterestRate == 1.8 &&
						len(acc.AccountNumber) > 0
				})).Return(&account.Account{
					ID:              "acc-123",
					UserID:          "user-123",
					AccountType:     account.FixedSavingsAccountType,
					AccountNumber:   "SAV123456789",
					Balance:         0.0,
					InterestRate:    func() *float64 { rate := 1.8; return &rate }(),
					FixedTermMonths: func() *int { term := 3; return &term }(),
				}, nil).Once()
			},
			expectedResult: &account.Account{
				ID:              "acc-123",
				UserID:          "user-123",
				AccountType:     account.FixedSavingsAccountType,
				AccountNumber:   "SAV123456789",
				Balance:         0.0,
				InterestRate:    func() *float64 { rate := 1.8; return &rate }(),
				FixedTermMonths: func() *int { term := 3; return &term }(),
			},
			expectedError: nil,
		},
		{
			name:       "error - user not found",
			userID:     "user-123",
			termMonths: 3,
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user not found
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(nil, errors.New("user not found")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("user not found"),
		},
		{
			name:       "error - profile not found",
			userID:     "user-123",
			termMonths: 3,
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile not found
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(nil, errors.New("profile not found")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("profile not found"),
		},
		{
			name:       "error - invalid term months",
			userID:     "user-123",
			termMonths: 2, // Invalid term
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()
			},
			expectedResult: nil,
			expectedError:  ErrInvalidTermMonths,
		},
		{
			name:       "error - savings account limit reached",
			userID:     "user-123",
			termMonths: 3,
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock savings accounts count >= 5
				accountRepo.EXPECT().
					CountSavingsAccounts(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(int64(5), nil).
					Once()
			},
			expectedResult: nil,
			expectedError:  ErrLimitSavingsAccount,
		},
		{
			name:       "error - count savings accounts fails",
			userID:     "user-123",
			termMonths: 3,
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock count fails
				accountRepo.EXPECT().
					CountSavingsAccounts(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(int64(0), errors.New("count failed")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("count failed"),
		},
		{
			name:       "error - account creation fails",
			userID:     "user-123",
			termMonths: 3,
			mockSetup: func(accountRepo *mocks.MockAccountRepository, userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository) {
				// Mock user exists
				userRepo.EXPECT().
					GetByID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.User{ID: "user-123"}, nil).
					Once()

				// Mock profile exists
				profileRepo.EXPECT().
					GetByUserID(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(&user.Profile{ID: "profile-123", UserID: "user-123"}, nil).
					Once()

				// Mock savings accounts count < 5
				accountRepo.EXPECT().
					CountSavingsAccounts(mock.Anything, mock.MatchedBy(func(userID string) bool {
						return userID == "user-123"
					})).
					Return(int64(2), nil).
					Once()

				// Mock account creation fails
				accountRepo.EXPECT().
					Create(mock.Anything, mock.Anything).
					Return(nil, errors.New("creation failed")).
					Once()
			},
			expectedResult: nil,
			expectedError:  errors.New("creation failed"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create mocks
			accountRepo := mocks.NewMockAccountRepository(t)
			userRepo := mocks.NewMockUserRepository(t)
			profileRepo := mocks.NewMockProfileRepository(t)

			// Setup mocks
			tt.mockSetup(accountRepo, userRepo, profileRepo)

			// Create service
			service := NewAccountService(accountRepo, userRepo, profileRepo, nil, nil)

			// Execute
			result, err := service.CreateFixedSavingsAccount(context.Background(), tt.userID, tt.termMonths)

			// Assert
			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
				assert.Nil(t, result)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, result)
				assert.Equal(t, tt.expectedResult.UserID, result.UserID)
				assert.Equal(t, tt.expectedResult.AccountType, result.AccountType)
				assert.Equal(t, tt.expectedResult.Balance, result.Balance)
				assert.Equal(t, *tt.expectedResult.InterestRate, *result.InterestRate)
				assert.Equal(t, *tt.expectedResult.FixedTermMonths, *result.FixedTermMonths)
			}
		})
	}
}

func TestAccountService_CalculateDailyInterest(t *testing.T) {
	tests := []struct {
		name          string
		mockSetup     func(*mocks.MockAccountRepository, *mocks.MockTransactionRepository, *mocks.MockInterestHistoryRepository)
		expectedError error
	}{
		{
			name: "success - calculate daily interest for multiple accounts",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, txRepo *mocks.MockTransactionRepository, ihRepo *mocks.MockInterestHistoryRepository) {
				// Mock GetFlexibleSavingsAccounts to return multiple accounts
				accounts := []*account.Account{
					{ID: "acc-1", UserID: "user-1", AccountType: account.FlexibleSavingsAccountType, Balance: 1000000, CreatedAt: time.Now().AddDate(0, 0, -90)},    // Older than 30 days, balance < 10M (annualRate = 0.003)
					{ID: "acc-2", UserID: "user-2", AccountType: account.FlexibleSavingsAccountType, Balance: 20000000, CreatedAt: time.Now().AddDate(0, 0, -10)}, // Newer than 30 days (annualRate = 0.008)
					{ID: "acc-3", UserID: "user-3", AccountType: account.FlexibleSavingsAccountType, Balance: 60000000, CreatedAt: time.Now().AddDate(0, 0, -90)}, // Older than 30 days, balance > 50M (annualRate = 0.005)
					{ID: "acc-4", UserID: "user-4", AccountType: account.FlexibleSavingsAccountType, Balance: 0, CreatedAt: time.Now().AddDate(0, 0, -90)},       // Zero balance (no interest)
					{ID: "acc-5", UserID: "user-5", AccountType: account.FlexibleSavingsAccountType, Balance: 30000000, CreatedAt: time.Now().AddDate(0, 0, -90)}, // Older than 30 days, 10M <= balance < 50M (annualRate = 0.004)
				}
				accountRepo.EXPECT().GetFlexibleSavingsAccounts(mock.Anything).Return(accounts, nil).Once()

				// Mock UpdateBalance for acc-1
				accountRepo.EXPECT().UpdateBalance(mock.Anything, "acc-1", mock.MatchedBy(func(balance float64) bool {
					return balance > 1000000 // Expecting interest to be added
				})).Return(nil).Once()

				// Mock Create transaction for acc-1
				txRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(tx *transaction.Transaction) bool {
					return tx.AccountID == "acc-1" && tx.TransactionType == transaction.TransactionTypeInterest
				})).Return(&transaction.Transaction{}, nil).Once()

				// Mock Create interest history for acc-1
				ihRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(ih *interest_history.InterestHistory) bool {
					return ih.AccountID == "acc-1"
				})).Return(&interest_history.InterestHistory{}, nil).Once()

				// Mock UpdateBalance for acc-2
				accountRepo.EXPECT().UpdateBalance(mock.Anything, "acc-2", mock.MatchedBy(func(balance float64) bool {
					return balance > 20000000 // Expecting interest to be added
				})).Return(nil).Once()

				// Mock Create transaction for acc-2
				txRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(tx *transaction.Transaction) bool {
					return tx.AccountID == "acc-2" && tx.TransactionType == transaction.TransactionTypeInterest
				})).Return(&transaction.Transaction{}, nil).Once()

				// Mock Create interest history for acc-2
				ihRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(ih *interest_history.InterestHistory) bool {
					return ih.AccountID == "acc-2"
				})).Return(&interest_history.InterestHistory{}, nil).Once()

				// Mock UpdateBalance for acc-3
				accountRepo.EXPECT().UpdateBalance(mock.Anything, "acc-3", mock.MatchedBy(func(balance float64) bool {
					return balance > 60000000 // Expecting interest to be added
				})).Return(nil).Once()

				// Mock Create transaction for acc-3
				txRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(tx *transaction.Transaction) bool {
					return tx.AccountID == "acc-3" && tx.TransactionType == transaction.TransactionTypeInterest
				})).Return(&transaction.Transaction{}, nil).Once()

				// Mock Create interest history for acc-3
				ihRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(ih *interest_history.InterestHistory) bool {
					return ih.AccountID == "acc-3"
				})).Return(&interest_history.InterestHistory{}, nil).Once()

				// acc-4 (zero balance) should not trigger UpdateBalance, Create, Create

				// Mock UpdateBalance for acc-5
				accountRepo.EXPECT().UpdateBalance(mock.Anything, "acc-5", mock.MatchedBy(func(balance float64) bool {
					return balance > 30000000 // Expecting interest to be added
				})).Return(nil).Once()

				// Mock Create transaction for acc-5
				txRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(tx *transaction.Transaction) bool {
					return tx.AccountID == "acc-5" && tx.TransactionType == transaction.TransactionTypeInterest
				})).Return(&transaction.Transaction{}, nil).Once()

				// Mock Create interest history for acc-5
				ihRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(ih *interest_history.InterestHistory) bool {
					return ih.AccountID == "acc-5"
				})).Return(&interest_history.InterestHistory{}, nil).Once()
			},
			expectedError: nil,
		},
		{
			name: "error - GetFlexibleSavingsAccounts fails",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, txRepo *mocks.MockTransactionRepository, ihRepo *mocks.MockInterestHistoryRepository) {
				accountRepo.EXPECT().GetFlexibleSavingsAccounts(mock.Anything).Return(nil, errors.New("db error")).Once()
			},
			expectedError: errors.New("db error"),
		},
		{
			name: "error - UpdateBalance fails",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, txRepo *mocks.MockTransactionRepository, ihRepo *mocks.MockInterestHistoryRepository) {
				accounts := []*account.Account{
					{ID: "acc-1", UserID: "user-1", AccountType: account.FlexibleSavingsAccountType, Balance: 1000000, CreatedAt: time.Now().AddDate(0, 0, -60)},
				}
				accountRepo.EXPECT().GetFlexibleSavingsAccounts(mock.Anything).Return(accounts, nil).Once()
				accountRepo.EXPECT().UpdateBalance(mock.Anything, "acc-1", mock.AnythingOfType("float64")).Return(errors.New("update error")).Once()
			},
			expectedError: errors.New("update error"),
		},
		{
			name: "error - Create transaction fails",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, txRepo *mocks.MockTransactionRepository, ihRepo *mocks.MockInterestHistoryRepository) {
				accounts := []*account.Account{
					{ID: "acc-1", UserID: "user-1", AccountType: account.FlexibleSavingsAccountType, Balance: 1000000, CreatedAt: time.Now().AddDate(0, 0, -60)},
				}
				accountRepo.EXPECT().GetFlexibleSavingsAccounts(mock.Anything).Return(accounts, nil).Once()
				accountRepo.EXPECT().UpdateBalance(mock.Anything, "acc-1", mock.AnythingOfType("float64")).Return(nil).Once()
				txRepo.EXPECT().Create(mock.Anything, mock.AnythingOfType("*transaction.Transaction")).Return(nil, errors.New("tx error")).Once()
			},
			expectedError: errors.New("tx error"),
		},
		{
			name: "error - Create interest history fails",
			mockSetup: func(accountRepo *mocks.MockAccountRepository, txRepo *mocks.MockTransactionRepository, ihRepo *mocks.MockInterestHistoryRepository) {
				accounts := []*account.Account{
					{ID: "acc-1", UserID: "user-1", AccountType: account.FlexibleSavingsAccountType, Balance: 1000000, CreatedAt: time.Now().AddDate(0, 0, -60)},
				}
				accountRepo.EXPECT().GetFlexibleSavingsAccounts(mock.Anything).Return(accounts, nil).Once()
				accountRepo.EXPECT().UpdateBalance(mock.Anything, "acc-1", mock.AnythingOfType("float64")).Return(nil).Once()
				txRepo.EXPECT().Create(mock.Anything, mock.AnythingOfType("*transaction.Transaction")).Return(&transaction.Transaction{}, nil).Once()
				ihRepo.EXPECT().Create(mock.Anything, mock.AnythingOfType("*interest_history.InterestHistory")).Return(nil, errors.New("ih error")).Once()
			},
			expectedError: errors.New("ih error"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create mocks
			accountRepo := mocks.NewMockAccountRepository(t)
			txRepo := mocks.NewMockTransactionRepository(t)
			ihRepo := mocks.NewMockInterestHistoryRepository(t)

			// Setup mocks
			tt.mockSetup(accountRepo, txRepo, ihRepo)

			// Create service
			service := NewAccountService(accountRepo, nil, nil, txRepo, ihRepo)

			// Execute
			err := service.CalculateDailyInterest(context.Background())

			// Assert
			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
			} else {
				assert.NoError(t, err)
			}
		})
	}
}
</file>

<file path="account/account_service.go">
package account

import (
	"context"
	"time"

	"e-wallet/internal/domain/account"
	"e-wallet/internal/domain/interest_history"
	"e-wallet/internal/domain/transaction"
	"e-wallet/internal/ports"
)

type accountService struct {
	repo        ports.AccountRepository
	userRepo    ports.UserRepository
	profileRepo ports.ProfileRepository
	txRepo      ports.TransactionRepository
	ihRepo      ports.InterestHistoryRepository
}

func NewAccountService(repo ports.AccountRepository, userRepo ports.UserRepository, profileRepo ports.ProfileRepository, txRepo ports.TransactionRepository, ihRepo ports.InterestHistoryRepository) ports.AccountService {
	return &accountService{repo: repo, userRepo: userRepo, profileRepo: profileRepo, txRepo: txRepo, ihRepo: ihRepo}
}

func (s *accountService) CreatePaymentAccount(ctx context.Context, userID string) (*account.Account, error) {
	// Check if user exists
	_, err := s.userRepo.GetByID(ctx, userID)
	if err != nil {
		return nil, err
	}

	// Check profile status (assume verified if profile exists)
	_, err = s.profileRepo.GetByUserID(ctx, userID)
	if err != nil {
		return nil, err
	}

	// Check if user already has a payment account
	_, err = s.repo.GetByUserID(ctx, userID)
	if err == nil {
		return nil, ErrLimitPaymentAccount
	}

	// Create account
	acc := account.NewPaymentAccount(userID)

	return s.repo.Create(ctx, acc)
}

func (s *accountService) CalculateDailyInterest(ctx context.Context) error {
	// Get yesterday's date
	yesterday := time.Now().AddDate(0, 0, -1)

	// Get all flexible savings accounts
	accounts, err := s.repo.GetFlexibleSavingsAccounts(ctx)
	if err != nil {
		return err
	}

	for _, acc := range accounts {
		// Calculate interest
		interestAmount := acc.CalculateDailyInterest()

		if interestAmount == 0 {
			continue
		}

		// Update balance
		newBalance := acc.Balance + interestAmount
		if err := s.repo.UpdateBalance(ctx, acc.ID, newBalance); err != nil {
			return err
		}

		// Create transaction
		tx := transaction.NewInterestTransaction(acc.ID, interestAmount, newBalance)
		if _, err := s.txRepo.Create(ctx, tx); err != nil {
			return err
		}

		// Create interest history
		ih := interest_history.NewInterestHistory(acc.ID, yesterday, interestAmount)
		if _, err := s.ihRepo.Create(ctx, ih); err != nil {
			return err
		}
	}

	return nil
}

func (s *accountService) CreateFlexibleSavingsAccount(ctx context.Context, userID string) (*account.Account, error) {
	// Check if user exists
	_, err := s.userRepo.GetByID(ctx, userID)
	if err != nil {
		return nil, err
	}

	// Check profile status (assume verified if profile exists)
	_, err = s.profileRepo.GetByUserID(ctx, userID)
	if err != nil {
		return nil, err
	}

	// Check limit savings accounts
	count, err := s.repo.CountSavingsAccounts(ctx, userID)
	if err != nil {
		return nil, err
	}
	if count >= 5 {
		return nil, ErrLimitSavingsAccount
	}

	// Create account
	acc := account.NewFlexibleSavingsAccount(userID)

	return s.repo.Create(ctx, acc)
}

func (s *accountService) CreateFixedSavingsAccount(ctx context.Context, userID string, termMonths int) (*account.Account, error) {
	// Check if user exists
	_, err := s.userRepo.GetByID(ctx, userID)
	if err != nil {
		return nil, err
	}

	// Check profile status (assume verified if profile exists)
	_, err = s.profileRepo.GetByUserID(ctx, userID)
	if err != nil {
		return nil, err
	}

	// Validate term months
	interestRate, ok := account.ValidTerms[termMonths]
	if !ok {
		return nil, ErrInvalidTermMonths
	}

	// Check limit savings accounts
	count, err := s.repo.CountSavingsAccounts(ctx, userID)
	if err != nil {
		return nil, err
	}
	if count >= 5 {
		return nil, ErrLimitSavingsAccount
	}

	// Create account
	acc := account.NewFixedSavingsAccount(userID, termMonths, interestRate)

	return s.repo.Create(ctx, acc)
}
</file>

<file path="account/errors.go">
package account

import "errors"

var (
	ErrLimitPaymentAccount  = errors.New("limit payment account")
	ErrLimitSavingsAccount  = errors.New("limit savings account")
	ErrInvalidTermMonths    = errors.New("invalid term months")
)
</file>

<file path="user/user_service_test.go">
package user

import (
	"context"
	"errors"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"golang.org/x/crypto/bcrypt"

	"e-wallet/internal/domain/user"
	"e-wallet/mocks"
)

// Helper function to hash password for tests
func hashPassword(password string) string {
	hashed, _ := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	return string(hashed)
}

func TestUserService_CreateUser(t *testing.T) {
	tests := []struct {
		name          string
		request       *user.CreateUserRequest
		mockSetup     func(*mocks.MockUserRepository, *mocks.MockProfileRepository, *mocks.MockPasswordService)
		expectedUser  *user.User
		expectedError error
	}{
		{
			name: "success - create user",
			request: &user.CreateUserRequest{
				Username: "testuser",
				Email:    "test@example.com",
				Password: "password123",
			},
			mockSetup: func(userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository, passwordService *mocks.MockPasswordService) {
				passwordService.EXPECT().HashPassword("password123").Return(hashPassword("password123"), nil).Once()
				userRepo.EXPECT().Create(mock.Anything, mock.MatchedBy(func(u *user.User) bool {
					return u.Username == "testuser" && u.Email == "test@example.com" && len(u.PasswordHash) > 0
				})).Return(&user.User{
					ID:           "user-123",
					Username:     "testuser",
					Email:        "test@example.com",
					PasswordHash: hashPassword("password123"),
				}, nil).Once()
			},
			expectedUser: &user.User{
				ID:       "user-123",
				Username: "testuser",
				Email:    "test@example.com",
			},
			expectedError: nil,
		},
		{
			name: "error - password hashing fails",
			request: &user.CreateUserRequest{
				Username: "testuser",
				Email:    "test@example.com",
				Password: "password123",
			},
			mockSetup: func(userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository, passwordService *mocks.MockPasswordService) {
				passwordService.EXPECT().HashPassword("password123").Return("", errors.New("hash error")).Once()
			},
			expectedUser:  nil,
			expectedError: errors.New("hash error"),
		},
		{
			name: "error - repository create fails",
			request: &user.CreateUserRequest{
				Username: "testuser",
				Email:    "test@example.com",
				Password: "password123",
			},
			mockSetup: func(userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository, passwordService *mocks.MockPasswordService) {
				passwordService.EXPECT().HashPassword("password123").Return(hashPassword("password123"), nil).Once()
				userRepo.EXPECT().Create(mock.Anything, mock.Anything).Return(nil, errors.New("db error")).Once()
			},
			expectedUser:  nil,
			expectedError: errors.New("db error"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			userRepo := mocks.NewMockUserRepository(t)
			profileRepo := mocks.NewMockProfileRepository(t)
			passwordService := mocks.NewMockPasswordService(t)

			tt.mockSetup(userRepo, profileRepo, passwordService)

			service := NewUserService(userRepo, profileRepo, passwordService)
			result, err := service.CreateUser(context.Background(), tt.request)

			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
				assert.Nil(t, result)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, result)
				assert.Equal(t, tt.expectedUser.Username, result.Username)
				assert.Equal(t, tt.expectedUser.Email, result.Email)
			}
		})
	}
}

func TestUserService_LoginUser(t *testing.T) {
	hashedPwd := hashPassword("password123")

	tests := []struct {
		name          string
		request       *user.LoginUserRequest
		mockSetup     func(*mocks.MockUserRepository, *mocks.MockProfileRepository, *mocks.MockPasswordService)
		expectedUser  *user.User
		expectedError error
	}{
		{
			name: "success - login user",
			request: &user.LoginUserRequest{
				Email:    "test@example.com",
				Password: "password123",
			},
			mockSetup: func(userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository, passwordService *mocks.MockPasswordService) {
				userRepo.EXPECT().GetByEmail(mock.Anything, "test@example.com").Return(&user.User{
					ID:           "user-123",
					Email:        "test@example.com",
					PasswordHash: hashedPwd,
				}, nil).Once()
				passwordService.EXPECT().CheckPassword(mock.Anything, "password123").Return(nil).Once()
			},
			expectedUser: &user.User{
				ID:    "user-123",
				Email: "test@example.com",
			},
			expectedError: nil,
		},
		{
			name: "error - user not found",
			request: &user.LoginUserRequest{
				Email:    "nonexistent@example.com",
				Password: "password123",
			},
			mockSetup: func(userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository, passwordService *mocks.MockPasswordService) {
				userRepo.EXPECT().GetByEmail(mock.Anything, "nonexistent@example.com").Return(nil, errors.New("user not found")).Once()
			},
			expectedUser:  nil,
			expectedError: errors.New("user not found"),
		},
		{
			name: "error - incorrect password",
			request: &user.LoginUserRequest{
				Email:    "test@example.com",
				Password: "wrongpassword",
			},
			mockSetup: func(userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository, passwordService *mocks.MockPasswordService) {
				userRepo.EXPECT().GetByEmail(mock.Anything, "test@example.com").Return(&user.User{
					ID:           "user-123",
					Email:        "test@example.com",
					PasswordHash: hashedPwd,
				}, nil).Once()
				passwordService.EXPECT().CheckPassword(mock.Anything, "wrongpassword").Return(bcrypt.ErrMismatchedHashAndPassword).Once()
			},
			expectedUser:  nil,
			expectedError: bcrypt.ErrMismatchedHashAndPassword,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			userRepo := mocks.NewMockUserRepository(t)
			profileRepo := mocks.NewMockProfileRepository(t)
			passwordService := mocks.NewMockPasswordService(t)

			tt.mockSetup(userRepo, profileRepo, passwordService)

			service := NewUserService(userRepo, profileRepo, passwordService)
			result, err := service.LoginUser(context.Background(), tt.request)

			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
				assert.Nil(t, result)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, result)
				assert.Equal(t, tt.expectedUser.Email, result.Email)
			}
		})
	}
}

func TestUserService_UpdateProfile(t *testing.T) {
	tests := []struct {
		name            string
		userID          string
		request         *user.UpdateProfileRequest
		mockSetup       func(*mocks.MockUserRepository, *mocks.MockProfileRepository, *mocks.MockPasswordService)
		expectedProfile *user.Profile
		expectedError   error
	}{
		{
			name:   "success - update profile",
			userID: "user-123",
			request: &user.UpdateProfileRequest{
				DisplayName: "Test User",
				AvatarURL:   "http://example.com/avatar.jpg",
			},
			mockSetup: func(userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository, passwordService *mocks.MockPasswordService) {
				profileRepo.EXPECT().Upsert(mock.Anything, mock.MatchedBy(func(p *user.Profile) bool {
					return p.UserID == "user-123" && p.DisplayName == "Test User"
				})).Return(&user.Profile{
					ID:          "profile-456",
					UserID:      "user-123",
					DisplayName: "Test User",
					AvatarURL:   "http://example.com/avatar.jpg",
				}, nil).Once()
			},
			expectedProfile: &user.Profile{
				ID:          "profile-456",
				UserID:      "user-123",
				DisplayName: "Test User",
				AvatarURL:   "http://example.com/avatar.jpg",
			},
			expectedError: nil,
		},
		{
			name:   "error - upsert fails",
			userID: "user-123",
			request: &user.UpdateProfileRequest{
				DisplayName: "Test User",
			},
			mockSetup: func(userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository, passwordService *mocks.MockPasswordService) {
				profileRepo.EXPECT().Upsert(mock.Anything, mock.Anything).Return(nil, errors.New("db error")).Once()
			},
			expectedProfile: nil,
			expectedError:   errors.New("db error"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			userRepo := mocks.NewMockUserRepository(t)
			profileRepo := mocks.NewMockProfileRepository(t)
			passwordService := mocks.NewMockPasswordService(t)

			tt.mockSetup(userRepo, profileRepo, passwordService)

			service := NewUserService(userRepo, profileRepo, passwordService)
			result, err := service.UpdateProfile(context.Background(), tt.userID, tt.request)

			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
				assert.Nil(t, result)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, result)
				assert.Equal(t, tt.expectedProfile.UserID, result.UserID)
				assert.Equal(t, tt.expectedProfile.DisplayName, result.DisplayName)
			}
		})
	}
}

func TestUserService_GetProfile(t *testing.T) {
	tests := []struct {
		name            string
		userID          string
		mockSetup       func(*mocks.MockUserRepository, *mocks.MockProfileRepository, *mocks.MockPasswordService)
		expectedProfile *user.Profile
		expectedError   error
	}{
		{
			name:   "success - get profile",
			userID: "user-123",
			mockSetup: func(userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository, passwordService *mocks.MockPasswordService) {
				profileRepo.EXPECT().GetByUserID(mock.Anything, "user-123").Return(&user.Profile{
					ID:     "profile-456",
					UserID: "user-123",
				}, nil).Once()
			},
			expectedProfile: &user.Profile{
				ID:     "profile-456",
				UserID: "user-123",
			},
			expectedError: nil,
		},
		{
			name:   "error - profile not found",
			userID: "user-123",
			mockSetup: func(userRepo *mocks.MockUserRepository, profileRepo *mocks.MockProfileRepository, passwordService *mocks.MockPasswordService) {
				profileRepo.EXPECT().GetByUserID(mock.Anything, "user-123").Return(nil, errors.New("profile not found")).Once()
			},
			expectedProfile: nil,
			expectedError:   errors.New("profile not found"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			userRepo := mocks.NewMockUserRepository(t)
			profileRepo := mocks.NewMockProfileRepository(t)
			passwordService := mocks.NewMockPasswordService(t)

			tt.mockSetup(userRepo, profileRepo, passwordService)

			service := NewUserService(userRepo, profileRepo, passwordService)
			result, err := service.GetProfile(context.Background(), tt.userID)

			if tt.expectedError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.expectedError.Error(), err.Error())
				assert.Nil(t, result)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, result)
				assert.Equal(t, tt.expectedProfile.UserID, result.UserID)
			}
		})
	}
}
</file>

<file path="user/user_service.go">
package user

import (
	"context"
	"e-wallet/internal/domain/user"
	"e-wallet/internal/ports"
)

type userService struct {
	repo            ports.UserRepository
	profileRepo     ports.ProfileRepository
	passwordService ports.PasswordService
}

func NewUserService(repo ports.UserRepository, profileRepo ports.ProfileRepository, passwordService ports.PasswordService) ports.UserService {
	return &userService{repo: repo, profileRepo: profileRepo, passwordService: passwordService}
}

func (s *userService) CreateUser(ctx context.Context, req *user.CreateUserRequest) (*user.User, error) {
	hashedPassword, err := s.passwordService.HashPassword(req.Password)
	if err != nil {
		return nil, err
	}

	u := user.NewUser(req.Username, req.Email, hashedPassword)

	return s.repo.Create(ctx, u)
}

func (s *userService) LoginUser(ctx context.Context, req *user.LoginUserRequest) (*user.User, error) {
	u, err := s.repo.GetByEmail(ctx, req.Email)
	if err != nil {
		return nil, err
	}

	if err := s.passwordService.CheckPassword(u.PasswordHash, req.Password); err != nil {
		return nil, err
	}

	return u, nil
}

func (s *userService) UpdateProfile(ctx context.Context, userID string, req *user.UpdateProfileRequest) (*user.Profile, error) {
	// Upsert profile
	profile := user.NewProfile(userID, req.DisplayName, req.AvatarURL, req.PhoneNumber, req.NationalID, req.Gender, req.Team, req.BirthYear)

	p, err := s.profileRepo.Upsert(ctx, profile)
	if err != nil {
		return nil, err
	}

	return p, nil
}

func (s *userService) GetProfile(ctx context.Context, userID string) (*user.Profile, error) {
	return s.profileRepo.GetByUserID(ctx, userID)
}
</file>

</files>
