// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"e-wallet/internal/domain/profile"
	"e-wallet/internal/domain/user"

	mock "github.com/stretchr/testify/mock"
)

// NewMockPasswordService creates a new instance of MockPasswordService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPasswordService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPasswordService {
	mock := &MockPasswordService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockPasswordService is an autogenerated mock type for the PasswordService type
type MockPasswordService struct {
	mock.Mock
}

type MockPasswordService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPasswordService) EXPECT() *MockPasswordService_Expecter {
	return &MockPasswordService_Expecter{mock: &_m.Mock}
}

// CheckPassword provides a mock function for the type MockPasswordService
func (_mock *MockPasswordService) CheckPassword(hashedPassword string, password string) error {
	ret := _mock.Called(hashedPassword, password)

	if len(ret) == 0 {
		panic("no return value specified for CheckPassword")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = returnFunc(hashedPassword, password)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPasswordService_CheckPassword_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckPassword'
type MockPasswordService_CheckPassword_Call struct {
	*mock.Call
}

// CheckPassword is a helper method to define mock.On call
//   - hashedPassword string
//   - password string
func (_e *MockPasswordService_Expecter) CheckPassword(hashedPassword interface{}, password interface{}) *MockPasswordService_CheckPassword_Call {
	return &MockPasswordService_CheckPassword_Call{Call: _e.mock.On("CheckPassword", hashedPassword, password)}
}

func (_c *MockPasswordService_CheckPassword_Call) Run(run func(hashedPassword string, password string)) *MockPasswordService_CheckPassword_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPasswordService_CheckPassword_Call) Return(err error) *MockPasswordService_CheckPassword_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPasswordService_CheckPassword_Call) RunAndReturn(run func(hashedPassword string, password string) error) *MockPasswordService_CheckPassword_Call {
	_c.Call.Return(run)
	return _c
}

// HashPassword provides a mock function for the type MockPasswordService
func (_mock *MockPasswordService) HashPassword(password string) (string, error) {
	ret := _mock.Called(password)

	if len(ret) == 0 {
		panic("no return value specified for HashPassword")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (string, error)); ok {
		return returnFunc(password)
	}
	if returnFunc, ok := ret.Get(0).(func(string) string); ok {
		r0 = returnFunc(password)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(password)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPasswordService_HashPassword_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashPassword'
type MockPasswordService_HashPassword_Call struct {
	*mock.Call
}

// HashPassword is a helper method to define mock.On call
//   - password string
func (_e *MockPasswordService_Expecter) HashPassword(password interface{}) *MockPasswordService_HashPassword_Call {
	return &MockPasswordService_HashPassword_Call{Call: _e.mock.On("HashPassword", password)}
}

func (_c *MockPasswordService_HashPassword_Call) Run(run func(password string)) *MockPasswordService_HashPassword_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPasswordService_HashPassword_Call) Return(s string, err error) *MockPasswordService_HashPassword_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockPasswordService_HashPassword_Call) RunAndReturn(run func(password string) (string, error)) *MockPasswordService_HashPassword_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProfileRepository creates a new instance of MockProfileRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProfileRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProfileRepository {
	mock := &MockProfileRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockProfileRepository is an autogenerated mock type for the ProfileRepository type
type MockProfileRepository struct {
	mock.Mock
}

type MockProfileRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProfileRepository) EXPECT() *MockProfileRepository_Expecter {
	return &MockProfileRepository_Expecter{mock: &_m.Mock}
}

// CheckNationalIDExists provides a mock function for the type MockProfileRepository
func (_mock *MockProfileRepository) CheckNationalIDExists(ctx context.Context, nationalID string, excludeUserID string) (bool, error) {
	ret := _mock.Called(ctx, nationalID, excludeUserID)

	if len(ret) == 0 {
		panic("no return value specified for CheckNationalIDExists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (bool, error)); ok {
		return returnFunc(ctx, nationalID, excludeUserID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = returnFunc(ctx, nationalID, excludeUserID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, nationalID, excludeUserID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProfileRepository_CheckNationalIDExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckNationalIDExists'
type MockProfileRepository_CheckNationalIDExists_Call struct {
	*mock.Call
}

// CheckNationalIDExists is a helper method to define mock.On call
//   - ctx context.Context
//   - nationalID string
//   - excludeUserID string
func (_e *MockProfileRepository_Expecter) CheckNationalIDExists(ctx interface{}, nationalID interface{}, excludeUserID interface{}) *MockProfileRepository_CheckNationalIDExists_Call {
	return &MockProfileRepository_CheckNationalIDExists_Call{Call: _e.mock.On("CheckNationalIDExists", ctx, nationalID, excludeUserID)}
}

func (_c *MockProfileRepository_CheckNationalIDExists_Call) Run(run func(ctx context.Context, nationalID string, excludeUserID string)) *MockProfileRepository_CheckNationalIDExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockProfileRepository_CheckNationalIDExists_Call) Return(b bool, err error) *MockProfileRepository_CheckNationalIDExists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockProfileRepository_CheckNationalIDExists_Call) RunAndReturn(run func(ctx context.Context, nationalID string, excludeUserID string) (bool, error)) *MockProfileRepository_CheckNationalIDExists_Call {
	_c.Call.Return(run)
	return _c
}

// GetByUserID provides a mock function for the type MockProfileRepository
func (_mock *MockProfileRepository) GetByUserID(ctx context.Context, userID string) (*profile.Profile, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetByUserID")
	}

	var r0 *profile.Profile
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*profile.Profile, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *profile.Profile); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*profile.Profile)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProfileRepository_GetByUserID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByUserID'
type MockProfileRepository_GetByUserID_Call struct {
	*mock.Call
}

// GetByUserID is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockProfileRepository_Expecter) GetByUserID(ctx interface{}, userID interface{}) *MockProfileRepository_GetByUserID_Call {
	return &MockProfileRepository_GetByUserID_Call{Call: _e.mock.On("GetByUserID", ctx, userID)}
}

func (_c *MockProfileRepository_GetByUserID_Call) Run(run func(ctx context.Context, userID string)) *MockProfileRepository_GetByUserID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProfileRepository_GetByUserID_Call) Return(profile1 *profile.Profile, err error) *MockProfileRepository_GetByUserID_Call {
	_c.Call.Return(profile1, err)
	return _c
}

func (_c *MockProfileRepository_GetByUserID_Call) RunAndReturn(run func(ctx context.Context, userID string) (*profile.Profile, error)) *MockProfileRepository_GetByUserID_Call {
	_c.Call.Return(run)
	return _c
}

// Upsert provides a mock function for the type MockProfileRepository
func (_mock *MockProfileRepository) Upsert(ctx context.Context, profile1 *profile.Profile) (*profile.Profile, error) {
	ret := _mock.Called(ctx, profile1)

	if len(ret) == 0 {
		panic("no return value specified for Upsert")
	}

	var r0 *profile.Profile
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *profile.Profile) (*profile.Profile, error)); ok {
		return returnFunc(ctx, profile1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *profile.Profile) *profile.Profile); ok {
		r0 = returnFunc(ctx, profile1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*profile.Profile)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *profile.Profile) error); ok {
		r1 = returnFunc(ctx, profile1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProfileRepository_Upsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Upsert'
type MockProfileRepository_Upsert_Call struct {
	*mock.Call
}

// Upsert is a helper method to define mock.On call
//   - ctx context.Context
//   - profile1 *profile.Profile
func (_e *MockProfileRepository_Expecter) Upsert(ctx interface{}, profile1 interface{}) *MockProfileRepository_Upsert_Call {
	return &MockProfileRepository_Upsert_Call{Call: _e.mock.On("Upsert", ctx, profile1)}
}

func (_c *MockProfileRepository_Upsert_Call) Run(run func(ctx context.Context, profile1 *profile.Profile)) *MockProfileRepository_Upsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *profile.Profile
		if args[1] != nil {
			arg1 = args[1].(*profile.Profile)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProfileRepository_Upsert_Call) Return(profile11 *profile.Profile, err error) *MockProfileRepository_Upsert_Call {
	_c.Call.Return(profile11, err)
	return _c
}

func (_c *MockProfileRepository_Upsert_Call) RunAndReturn(run func(ctx context.Context, profile1 *profile.Profile) (*profile.Profile, error)) *MockProfileRepository_Upsert_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProfileService creates a new instance of MockProfileService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProfileService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProfileService {
	mock := &MockProfileService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockProfileService is an autogenerated mock type for the ProfileService type
type MockProfileService struct {
	mock.Mock
}

type MockProfileService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProfileService) EXPECT() *MockProfileService_Expecter {
	return &MockProfileService_Expecter{mock: &_m.Mock}
}

// GetProfile provides a mock function for the type MockProfileService
func (_mock *MockProfileService) GetProfile(ctx context.Context, userID string) (*profile.Profile, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetProfile")
	}

	var r0 *profile.Profile
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*profile.Profile, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *profile.Profile); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*profile.Profile)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProfileService_GetProfile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProfile'
type MockProfileService_GetProfile_Call struct {
	*mock.Call
}

// GetProfile is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockProfileService_Expecter) GetProfile(ctx interface{}, userID interface{}) *MockProfileService_GetProfile_Call {
	return &MockProfileService_GetProfile_Call{Call: _e.mock.On("GetProfile", ctx, userID)}
}

func (_c *MockProfileService_GetProfile_Call) Run(run func(ctx context.Context, userID string)) *MockProfileService_GetProfile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProfileService_GetProfile_Call) Return(profile1 *profile.Profile, err error) *MockProfileService_GetProfile_Call {
	_c.Call.Return(profile1, err)
	return _c
}

func (_c *MockProfileService_GetProfile_Call) RunAndReturn(run func(ctx context.Context, userID string) (*profile.Profile, error)) *MockProfileService_GetProfile_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProfile provides a mock function for the type MockProfileService
func (_mock *MockProfileService) UpdateProfile(ctx context.Context, userID string, req *profile.UpdateProfileRequest) (*profile.Profile, error) {
	ret := _mock.Called(ctx, userID, req)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProfile")
	}

	var r0 *profile.Profile
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *profile.UpdateProfileRequest) (*profile.Profile, error)); ok {
		return returnFunc(ctx, userID, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *profile.UpdateProfileRequest) *profile.Profile); ok {
		r0 = returnFunc(ctx, userID, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*profile.Profile)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, *profile.UpdateProfileRequest) error); ok {
		r1 = returnFunc(ctx, userID, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProfileService_UpdateProfile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProfile'
type MockProfileService_UpdateProfile_Call struct {
	*mock.Call
}

// UpdateProfile is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - req *profile.UpdateProfileRequest
func (_e *MockProfileService_Expecter) UpdateProfile(ctx interface{}, userID interface{}, req interface{}) *MockProfileService_UpdateProfile_Call {
	return &MockProfileService_UpdateProfile_Call{Call: _e.mock.On("UpdateProfile", ctx, userID, req)}
}

func (_c *MockProfileService_UpdateProfile_Call) Run(run func(ctx context.Context, userID string, req *profile.UpdateProfileRequest)) *MockProfileService_UpdateProfile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 *profile.UpdateProfileRequest
		if args[2] != nil {
			arg2 = args[2].(*profile.UpdateProfileRequest)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockProfileService_UpdateProfile_Call) Return(profile1 *profile.Profile, err error) *MockProfileService_UpdateProfile_Call {
	_c.Call.Return(profile1, err)
	return _c
}

func (_c *MockProfileService_UpdateProfile_Call) RunAndReturn(run func(ctx context.Context, userID string, req *profile.UpdateProfileRequest) (*profile.Profile, error)) *MockProfileService_UpdateProfile_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUserRepository creates a new instance of MockUserRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUserRepository {
	mock := &MockUserRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUserRepository is an autogenerated mock type for the UserRepository type
type MockUserRepository struct {
	mock.Mock
}

type MockUserRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUserRepository) EXPECT() *MockUserRepository_Expecter {
	return &MockUserRepository_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) Create(ctx context.Context, user1 *user.User) (*user.User, error) {
	ret := _mock.Called(ctx, user1)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *user.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.User) (*user.User, error)); ok {
		return returnFunc(ctx, user1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.User) *user.User); ok {
		r0 = returnFunc(ctx, user1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *user.User) error); ok {
		r1 = returnFunc(ctx, user1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockUserRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - user1 *user.User
func (_e *MockUserRepository_Expecter) Create(ctx interface{}, user1 interface{}) *MockUserRepository_Create_Call {
	return &MockUserRepository_Create_Call{Call: _e.mock.On("Create", ctx, user1)}
}

func (_c *MockUserRepository_Create_Call) Run(run func(ctx context.Context, user1 *user.User)) *MockUserRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *user.User
		if args[1] != nil {
			arg1 = args[1].(*user.User)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserRepository_Create_Call) Return(user11 *user.User, err error) *MockUserRepository_Create_Call {
	_c.Call.Return(user11, err)
	return _c
}

func (_c *MockUserRepository_Create_Call) RunAndReturn(run func(ctx context.Context, user1 *user.User) (*user.User, error)) *MockUserRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// GetByEmail provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) GetByEmail(ctx context.Context, email string) (*user.User, error) {
	ret := _mock.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for GetByEmail")
	}

	var r0 *user.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*user.User, error)); ok {
		return returnFunc(ctx, email)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *user.User); ok {
		r0 = returnFunc(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, email)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserRepository_GetByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByEmail'
type MockUserRepository_GetByEmail_Call struct {
	*mock.Call
}

// GetByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *MockUserRepository_Expecter) GetByEmail(ctx interface{}, email interface{}) *MockUserRepository_GetByEmail_Call {
	return &MockUserRepository_GetByEmail_Call{Call: _e.mock.On("GetByEmail", ctx, email)}
}

func (_c *MockUserRepository_GetByEmail_Call) Run(run func(ctx context.Context, email string)) *MockUserRepository_GetByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserRepository_GetByEmail_Call) Return(user1 *user.User, err error) *MockUserRepository_GetByEmail_Call {
	_c.Call.Return(user1, err)
	return _c
}

func (_c *MockUserRepository_GetByEmail_Call) RunAndReturn(run func(ctx context.Context, email string) (*user.User, error)) *MockUserRepository_GetByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// GetByID provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) GetByID(ctx context.Context, id string) (*user.User, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 *user.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*user.User, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *user.User); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockUserRepository_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockUserRepository_Expecter) GetByID(ctx interface{}, id interface{}) *MockUserRepository_GetByID_Call {
	return &MockUserRepository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, id)}
}

func (_c *MockUserRepository_GetByID_Call) Run(run func(ctx context.Context, id string)) *MockUserRepository_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserRepository_GetByID_Call) Return(user1 *user.User, err error) *MockUserRepository_GetByID_Call {
	_c.Call.Return(user1, err)
	return _c
}

func (_c *MockUserRepository_GetByID_Call) RunAndReturn(run func(ctx context.Context, id string) (*user.User, error)) *MockUserRepository_GetByID_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProfileCompleted provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) UpdateProfileCompleted(ctx context.Context, id string, completed bool) error {
	ret := _mock.Called(ctx, id, completed)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProfileCompleted")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, bool) error); ok {
		r0 = returnFunc(ctx, id, completed)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockUserRepository_UpdateProfileCompleted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProfileCompleted'
type MockUserRepository_UpdateProfileCompleted_Call struct {
	*mock.Call
}

// UpdateProfileCompleted is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - completed bool
func (_e *MockUserRepository_Expecter) UpdateProfileCompleted(ctx interface{}, id interface{}, completed interface{}) *MockUserRepository_UpdateProfileCompleted_Call {
	return &MockUserRepository_UpdateProfileCompleted_Call{Call: _e.mock.On("UpdateProfileCompleted", ctx, id, completed)}
}

func (_c *MockUserRepository_UpdateProfileCompleted_Call) Run(run func(ctx context.Context, id string, completed bool)) *MockUserRepository_UpdateProfileCompleted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 bool
		if args[2] != nil {
			arg2 = args[2].(bool)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockUserRepository_UpdateProfileCompleted_Call) Return(err error) *MockUserRepository_UpdateProfileCompleted_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockUserRepository_UpdateProfileCompleted_Call) RunAndReturn(run func(ctx context.Context, id string, completed bool) error) *MockUserRepository_UpdateProfileCompleted_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUserService creates a new instance of MockUserService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUserService {
	mock := &MockUserService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUserService is an autogenerated mock type for the UserService type
type MockUserService struct {
	mock.Mock
}

type MockUserService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUserService) EXPECT() *MockUserService_Expecter {
	return &MockUserService_Expecter{mock: &_m.Mock}
}

// CreateUser provides a mock function for the type MockUserService
func (_mock *MockUserService) CreateUser(ctx context.Context, req *user.CreateUserRequest) (*user.User, error) {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 *user.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.CreateUserRequest) (*user.User, error)); ok {
		return returnFunc(ctx, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.CreateUserRequest) *user.User); ok {
		r0 = returnFunc(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *user.CreateUserRequest) error); ok {
		r1 = returnFunc(ctx, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserService_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type MockUserService_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - req *user.CreateUserRequest
func (_e *MockUserService_Expecter) CreateUser(ctx interface{}, req interface{}) *MockUserService_CreateUser_Call {
	return &MockUserService_CreateUser_Call{Call: _e.mock.On("CreateUser", ctx, req)}
}

func (_c *MockUserService_CreateUser_Call) Run(run func(ctx context.Context, req *user.CreateUserRequest)) *MockUserService_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *user.CreateUserRequest
		if args[1] != nil {
			arg1 = args[1].(*user.CreateUserRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserService_CreateUser_Call) Return(user1 *user.User, err error) *MockUserService_CreateUser_Call {
	_c.Call.Return(user1, err)
	return _c
}

func (_c *MockUserService_CreateUser_Call) RunAndReturn(run func(ctx context.Context, req *user.CreateUserRequest) (*user.User, error)) *MockUserService_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// LoginUser provides a mock function for the type MockUserService
func (_mock *MockUserService) LoginUser(ctx context.Context, req *user.LoginUserRequest) (*user.User, error) {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for LoginUser")
	}

	var r0 *user.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.LoginUserRequest) (*user.User, error)); ok {
		return returnFunc(ctx, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.LoginUserRequest) *user.User); ok {
		r0 = returnFunc(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *user.LoginUserRequest) error); ok {
		r1 = returnFunc(ctx, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserService_LoginUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoginUser'
type MockUserService_LoginUser_Call struct {
	*mock.Call
}

// LoginUser is a helper method to define mock.On call
//   - ctx context.Context
//   - req *user.LoginUserRequest
func (_e *MockUserService_Expecter) LoginUser(ctx interface{}, req interface{}) *MockUserService_LoginUser_Call {
	return &MockUserService_LoginUser_Call{Call: _e.mock.On("LoginUser", ctx, req)}
}

func (_c *MockUserService_LoginUser_Call) Run(run func(ctx context.Context, req *user.LoginUserRequest)) *MockUserService_LoginUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *user.LoginUserRequest
		if args[1] != nil {
			arg1 = args[1].(*user.LoginUserRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserService_LoginUser_Call) Return(user1 *user.User, err error) *MockUserService_LoginUser_Call {
	_c.Call.Return(user1, err)
	return _c
}

func (_c *MockUserService_LoginUser_Call) RunAndReturn(run func(ctx context.Context, req *user.LoginUserRequest) (*user.User, error)) *MockUserService_LoginUser_Call {
	_c.Call.Return(run)
	return _c
}
