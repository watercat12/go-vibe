// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"e-wallet/internal/domain/account"
	"e-wallet/internal/domain/interest_history"
	"e-wallet/internal/domain/transaction"
	"e-wallet/internal/domain/user"

	mock "github.com/stretchr/testify/mock"
)

// NewMockAccountRepository creates a new instance of MockAccountRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAccountRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAccountRepository {
	mock := &MockAccountRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockAccountRepository is an autogenerated mock type for the AccountRepository type
type MockAccountRepository struct {
	mock.Mock
}

type MockAccountRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAccountRepository) EXPECT() *MockAccountRepository_Expecter {
	return &MockAccountRepository_Expecter{mock: &_m.Mock}
}

// CountSavingsAccounts provides a mock function for the type MockAccountRepository
func (_mock *MockAccountRepository) CountSavingsAccounts(ctx context.Context, userID string) (int64, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for CountSavingsAccounts")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (int64, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccountRepository_CountSavingsAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountSavingsAccounts'
type MockAccountRepository_CountSavingsAccounts_Call struct {
	*mock.Call
}

// CountSavingsAccounts is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockAccountRepository_Expecter) CountSavingsAccounts(ctx interface{}, userID interface{}) *MockAccountRepository_CountSavingsAccounts_Call {
	return &MockAccountRepository_CountSavingsAccounts_Call{Call: _e.mock.On("CountSavingsAccounts", ctx, userID)}
}

func (_c *MockAccountRepository_CountSavingsAccounts_Call) Run(run func(ctx context.Context, userID string)) *MockAccountRepository_CountSavingsAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAccountRepository_CountSavingsAccounts_Call) Return(n int64, err error) *MockAccountRepository_CountSavingsAccounts_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockAccountRepository_CountSavingsAccounts_Call) RunAndReturn(run func(ctx context.Context, userID string) (int64, error)) *MockAccountRepository_CountSavingsAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockAccountRepository
func (_mock *MockAccountRepository) Create(ctx context.Context, account1 *account.Account) (*account.Account, error) {
	ret := _mock.Called(ctx, account1)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *account.Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *account.Account) (*account.Account, error)); ok {
		return returnFunc(ctx, account1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *account.Account) *account.Account); ok {
		r0 = returnFunc(ctx, account1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *account.Account) error); ok {
		r1 = returnFunc(ctx, account1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccountRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockAccountRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - account1 *account.Account
func (_e *MockAccountRepository_Expecter) Create(ctx interface{}, account1 interface{}) *MockAccountRepository_Create_Call {
	return &MockAccountRepository_Create_Call{Call: _e.mock.On("Create", ctx, account1)}
}

func (_c *MockAccountRepository_Create_Call) Run(run func(ctx context.Context, account1 *account.Account)) *MockAccountRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *account.Account
		if args[1] != nil {
			arg1 = args[1].(*account.Account)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAccountRepository_Create_Call) Return(account11 *account.Account, err error) *MockAccountRepository_Create_Call {
	_c.Call.Return(account11, err)
	return _c
}

func (_c *MockAccountRepository_Create_Call) RunAndReturn(run func(ctx context.Context, account1 *account.Account) (*account.Account, error)) *MockAccountRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// GetByID provides a mock function for the type MockAccountRepository
func (_mock *MockAccountRepository) GetByID(ctx context.Context, id string) (*account.Account, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 *account.Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*account.Account, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *account.Account); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccountRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockAccountRepository_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockAccountRepository_Expecter) GetByID(ctx interface{}, id interface{}) *MockAccountRepository_GetByID_Call {
	return &MockAccountRepository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, id)}
}

func (_c *MockAccountRepository_GetByID_Call) Run(run func(ctx context.Context, id string)) *MockAccountRepository_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAccountRepository_GetByID_Call) Return(account1 *account.Account, err error) *MockAccountRepository_GetByID_Call {
	_c.Call.Return(account1, err)
	return _c
}

func (_c *MockAccountRepository_GetByID_Call) RunAndReturn(run func(ctx context.Context, id string) (*account.Account, error)) *MockAccountRepository_GetByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetByUserID provides a mock function for the type MockAccountRepository
func (_mock *MockAccountRepository) GetByUserID(ctx context.Context, userID string) (*account.Account, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetByUserID")
	}

	var r0 *account.Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*account.Account, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *account.Account); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccountRepository_GetByUserID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByUserID'
type MockAccountRepository_GetByUserID_Call struct {
	*mock.Call
}

// GetByUserID is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockAccountRepository_Expecter) GetByUserID(ctx interface{}, userID interface{}) *MockAccountRepository_GetByUserID_Call {
	return &MockAccountRepository_GetByUserID_Call{Call: _e.mock.On("GetByUserID", ctx, userID)}
}

func (_c *MockAccountRepository_GetByUserID_Call) Run(run func(ctx context.Context, userID string)) *MockAccountRepository_GetByUserID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAccountRepository_GetByUserID_Call) Return(account1 *account.Account, err error) *MockAccountRepository_GetByUserID_Call {
	_c.Call.Return(account1, err)
	return _c
}

func (_c *MockAccountRepository_GetByUserID_Call) RunAndReturn(run func(ctx context.Context, userID string) (*account.Account, error)) *MockAccountRepository_GetByUserID_Call {
	_c.Call.Return(run)
	return _c
}

// GetFlexibleSavingsAccounts provides a mock function for the type MockAccountRepository
func (_mock *MockAccountRepository) GetFlexibleSavingsAccounts(ctx context.Context) ([]*account.Account, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetFlexibleSavingsAccounts")
	}

	var r0 []*account.Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]*account.Account, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []*account.Account); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*account.Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccountRepository_GetFlexibleSavingsAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFlexibleSavingsAccounts'
type MockAccountRepository_GetFlexibleSavingsAccounts_Call struct {
	*mock.Call
}

// GetFlexibleSavingsAccounts is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockAccountRepository_Expecter) GetFlexibleSavingsAccounts(ctx interface{}) *MockAccountRepository_GetFlexibleSavingsAccounts_Call {
	return &MockAccountRepository_GetFlexibleSavingsAccounts_Call{Call: _e.mock.On("GetFlexibleSavingsAccounts", ctx)}
}

func (_c *MockAccountRepository_GetFlexibleSavingsAccounts_Call) Run(run func(ctx context.Context)) *MockAccountRepository_GetFlexibleSavingsAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockAccountRepository_GetFlexibleSavingsAccounts_Call) Return(accounts []*account.Account, err error) *MockAccountRepository_GetFlexibleSavingsAccounts_Call {
	_c.Call.Return(accounts, err)
	return _c
}

func (_c *MockAccountRepository_GetFlexibleSavingsAccounts_Call) RunAndReturn(run func(ctx context.Context) ([]*account.Account, error)) *MockAccountRepository_GetFlexibleSavingsAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateBalance provides a mock function for the type MockAccountRepository
func (_mock *MockAccountRepository) UpdateBalance(ctx context.Context, id string, balance float64) error {
	ret := _mock.Called(ctx, id, balance)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBalance")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, float64) error); ok {
		r0 = returnFunc(ctx, id, balance)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockAccountRepository_UpdateBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateBalance'
type MockAccountRepository_UpdateBalance_Call struct {
	*mock.Call
}

// UpdateBalance is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - balance float64
func (_e *MockAccountRepository_Expecter) UpdateBalance(ctx interface{}, id interface{}, balance interface{}) *MockAccountRepository_UpdateBalance_Call {
	return &MockAccountRepository_UpdateBalance_Call{Call: _e.mock.On("UpdateBalance", ctx, id, balance)}
}

func (_c *MockAccountRepository_UpdateBalance_Call) Run(run func(ctx context.Context, id string, balance float64)) *MockAccountRepository_UpdateBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 float64
		if args[2] != nil {
			arg2 = args[2].(float64)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockAccountRepository_UpdateBalance_Call) Return(err error) *MockAccountRepository_UpdateBalance_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockAccountRepository_UpdateBalance_Call) RunAndReturn(run func(ctx context.Context, id string, balance float64) error) *MockAccountRepository_UpdateBalance_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockAccountService creates a new instance of MockAccountService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAccountService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAccountService {
	mock := &MockAccountService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockAccountService is an autogenerated mock type for the AccountService type
type MockAccountService struct {
	mock.Mock
}

type MockAccountService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAccountService) EXPECT() *MockAccountService_Expecter {
	return &MockAccountService_Expecter{mock: &_m.Mock}
}

// CalculateDailyInterest provides a mock function for the type MockAccountService
func (_mock *MockAccountService) CalculateDailyInterest(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CalculateDailyInterest")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockAccountService_CalculateDailyInterest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CalculateDailyInterest'
type MockAccountService_CalculateDailyInterest_Call struct {
	*mock.Call
}

// CalculateDailyInterest is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockAccountService_Expecter) CalculateDailyInterest(ctx interface{}) *MockAccountService_CalculateDailyInterest_Call {
	return &MockAccountService_CalculateDailyInterest_Call{Call: _e.mock.On("CalculateDailyInterest", ctx)}
}

func (_c *MockAccountService_CalculateDailyInterest_Call) Run(run func(ctx context.Context)) *MockAccountService_CalculateDailyInterest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockAccountService_CalculateDailyInterest_Call) Return(err error) *MockAccountService_CalculateDailyInterest_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockAccountService_CalculateDailyInterest_Call) RunAndReturn(run func(ctx context.Context) error) *MockAccountService_CalculateDailyInterest_Call {
	_c.Call.Return(run)
	return _c
}

// CreateFixedSavingsAccount provides a mock function for the type MockAccountService
func (_mock *MockAccountService) CreateFixedSavingsAccount(ctx context.Context, userID string, termMonths int) (*account.Account, error) {
	ret := _mock.Called(ctx, userID, termMonths)

	if len(ret) == 0 {
		panic("no return value specified for CreateFixedSavingsAccount")
	}

	var r0 *account.Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int) (*account.Account, error)); ok {
		return returnFunc(ctx, userID, termMonths)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, int) *account.Account); ok {
		r0 = returnFunc(ctx, userID, termMonths)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, int) error); ok {
		r1 = returnFunc(ctx, userID, termMonths)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccountService_CreateFixedSavingsAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateFixedSavingsAccount'
type MockAccountService_CreateFixedSavingsAccount_Call struct {
	*mock.Call
}

// CreateFixedSavingsAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - termMonths int
func (_e *MockAccountService_Expecter) CreateFixedSavingsAccount(ctx interface{}, userID interface{}, termMonths interface{}) *MockAccountService_CreateFixedSavingsAccount_Call {
	return &MockAccountService_CreateFixedSavingsAccount_Call{Call: _e.mock.On("CreateFixedSavingsAccount", ctx, userID, termMonths)}
}

func (_c *MockAccountService_CreateFixedSavingsAccount_Call) Run(run func(ctx context.Context, userID string, termMonths int)) *MockAccountService_CreateFixedSavingsAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockAccountService_CreateFixedSavingsAccount_Call) Return(account1 *account.Account, err error) *MockAccountService_CreateFixedSavingsAccount_Call {
	_c.Call.Return(account1, err)
	return _c
}

func (_c *MockAccountService_CreateFixedSavingsAccount_Call) RunAndReturn(run func(ctx context.Context, userID string, termMonths int) (*account.Account, error)) *MockAccountService_CreateFixedSavingsAccount_Call {
	_c.Call.Return(run)
	return _c
}

// CreateFlexibleSavingsAccount provides a mock function for the type MockAccountService
func (_mock *MockAccountService) CreateFlexibleSavingsAccount(ctx context.Context, userID string) (*account.Account, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for CreateFlexibleSavingsAccount")
	}

	var r0 *account.Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*account.Account, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *account.Account); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccountService_CreateFlexibleSavingsAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateFlexibleSavingsAccount'
type MockAccountService_CreateFlexibleSavingsAccount_Call struct {
	*mock.Call
}

// CreateFlexibleSavingsAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockAccountService_Expecter) CreateFlexibleSavingsAccount(ctx interface{}, userID interface{}) *MockAccountService_CreateFlexibleSavingsAccount_Call {
	return &MockAccountService_CreateFlexibleSavingsAccount_Call{Call: _e.mock.On("CreateFlexibleSavingsAccount", ctx, userID)}
}

func (_c *MockAccountService_CreateFlexibleSavingsAccount_Call) Run(run func(ctx context.Context, userID string)) *MockAccountService_CreateFlexibleSavingsAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAccountService_CreateFlexibleSavingsAccount_Call) Return(account1 *account.Account, err error) *MockAccountService_CreateFlexibleSavingsAccount_Call {
	_c.Call.Return(account1, err)
	return _c
}

func (_c *MockAccountService_CreateFlexibleSavingsAccount_Call) RunAndReturn(run func(ctx context.Context, userID string) (*account.Account, error)) *MockAccountService_CreateFlexibleSavingsAccount_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePaymentAccount provides a mock function for the type MockAccountService
func (_mock *MockAccountService) CreatePaymentAccount(ctx context.Context, userID string) (*account.Account, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for CreatePaymentAccount")
	}

	var r0 *account.Account
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*account.Account, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *account.Account); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.Account)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccountService_CreatePaymentAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePaymentAccount'
type MockAccountService_CreatePaymentAccount_Call struct {
	*mock.Call
}

// CreatePaymentAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockAccountService_Expecter) CreatePaymentAccount(ctx interface{}, userID interface{}) *MockAccountService_CreatePaymentAccount_Call {
	return &MockAccountService_CreatePaymentAccount_Call{Call: _e.mock.On("CreatePaymentAccount", ctx, userID)}
}

func (_c *MockAccountService_CreatePaymentAccount_Call) Run(run func(ctx context.Context, userID string)) *MockAccountService_CreatePaymentAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAccountService_CreatePaymentAccount_Call) Return(account1 *account.Account, err error) *MockAccountService_CreatePaymentAccount_Call {
	_c.Call.Return(account1, err)
	return _c
}

func (_c *MockAccountService_CreatePaymentAccount_Call) RunAndReturn(run func(ctx context.Context, userID string) (*account.Account, error)) *MockAccountService_CreatePaymentAccount_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockInterestHistoryRepository creates a new instance of MockInterestHistoryRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockInterestHistoryRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockInterestHistoryRepository {
	mock := &MockInterestHistoryRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockInterestHistoryRepository is an autogenerated mock type for the InterestHistoryRepository type
type MockInterestHistoryRepository struct {
	mock.Mock
}

type MockInterestHistoryRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockInterestHistoryRepository) EXPECT() *MockInterestHistoryRepository_Expecter {
	return &MockInterestHistoryRepository_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockInterestHistoryRepository
func (_mock *MockInterestHistoryRepository) Create(ctx context.Context, ih *interest_history.InterestHistory) (*interest_history.InterestHistory, error) {
	ret := _mock.Called(ctx, ih)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *interest_history.InterestHistory
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *interest_history.InterestHistory) (*interest_history.InterestHistory, error)); ok {
		return returnFunc(ctx, ih)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *interest_history.InterestHistory) *interest_history.InterestHistory); ok {
		r0 = returnFunc(ctx, ih)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*interest_history.InterestHistory)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *interest_history.InterestHistory) error); ok {
		r1 = returnFunc(ctx, ih)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockInterestHistoryRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockInterestHistoryRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - ih *interest_history.InterestHistory
func (_e *MockInterestHistoryRepository_Expecter) Create(ctx interface{}, ih interface{}) *MockInterestHistoryRepository_Create_Call {
	return &MockInterestHistoryRepository_Create_Call{Call: _e.mock.On("Create", ctx, ih)}
}

func (_c *MockInterestHistoryRepository_Create_Call) Run(run func(ctx context.Context, ih *interest_history.InterestHistory)) *MockInterestHistoryRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *interest_history.InterestHistory
		if args[1] != nil {
			arg1 = args[1].(*interest_history.InterestHistory)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockInterestHistoryRepository_Create_Call) Return(interestHistory *interest_history.InterestHistory, err error) *MockInterestHistoryRepository_Create_Call {
	_c.Call.Return(interestHistory, err)
	return _c
}

func (_c *MockInterestHistoryRepository_Create_Call) RunAndReturn(run func(ctx context.Context, ih *interest_history.InterestHistory) (*interest_history.InterestHistory, error)) *MockInterestHistoryRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockProfileRepository creates a new instance of MockProfileRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProfileRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockProfileRepository {
	mock := &MockProfileRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockProfileRepository is an autogenerated mock type for the ProfileRepository type
type MockProfileRepository struct {
	mock.Mock
}

type MockProfileRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockProfileRepository) EXPECT() *MockProfileRepository_Expecter {
	return &MockProfileRepository_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockProfileRepository
func (_mock *MockProfileRepository) Create(ctx context.Context, profile *user.Profile) (*user.Profile, error) {
	ret := _mock.Called(ctx, profile)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *user.Profile
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.Profile) (*user.Profile, error)); ok {
		return returnFunc(ctx, profile)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.Profile) *user.Profile); ok {
		r0 = returnFunc(ctx, profile)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.Profile)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *user.Profile) error); ok {
		r1 = returnFunc(ctx, profile)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProfileRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockProfileRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - profile *user.Profile
func (_e *MockProfileRepository_Expecter) Create(ctx interface{}, profile interface{}) *MockProfileRepository_Create_Call {
	return &MockProfileRepository_Create_Call{Call: _e.mock.On("Create", ctx, profile)}
}

func (_c *MockProfileRepository_Create_Call) Run(run func(ctx context.Context, profile *user.Profile)) *MockProfileRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *user.Profile
		if args[1] != nil {
			arg1 = args[1].(*user.Profile)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProfileRepository_Create_Call) Return(profile1 *user.Profile, err error) *MockProfileRepository_Create_Call {
	_c.Call.Return(profile1, err)
	return _c
}

func (_c *MockProfileRepository_Create_Call) RunAndReturn(run func(ctx context.Context, profile *user.Profile) (*user.Profile, error)) *MockProfileRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// GetByUserID provides a mock function for the type MockProfileRepository
func (_mock *MockProfileRepository) GetByUserID(ctx context.Context, userID string) (*user.Profile, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetByUserID")
	}

	var r0 *user.Profile
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*user.Profile, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *user.Profile); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.Profile)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProfileRepository_GetByUserID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByUserID'
type MockProfileRepository_GetByUserID_Call struct {
	*mock.Call
}

// GetByUserID is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockProfileRepository_Expecter) GetByUserID(ctx interface{}, userID interface{}) *MockProfileRepository_GetByUserID_Call {
	return &MockProfileRepository_GetByUserID_Call{Call: _e.mock.On("GetByUserID", ctx, userID)}
}

func (_c *MockProfileRepository_GetByUserID_Call) Run(run func(ctx context.Context, userID string)) *MockProfileRepository_GetByUserID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProfileRepository_GetByUserID_Call) Return(profile *user.Profile, err error) *MockProfileRepository_GetByUserID_Call {
	_c.Call.Return(profile, err)
	return _c
}

func (_c *MockProfileRepository_GetByUserID_Call) RunAndReturn(run func(ctx context.Context, userID string) (*user.Profile, error)) *MockProfileRepository_GetByUserID_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type MockProfileRepository
func (_mock *MockProfileRepository) Update(ctx context.Context, profile *user.Profile) (*user.Profile, error) {
	ret := _mock.Called(ctx, profile)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 *user.Profile
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.Profile) (*user.Profile, error)); ok {
		return returnFunc(ctx, profile)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.Profile) *user.Profile); ok {
		r0 = returnFunc(ctx, profile)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.Profile)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *user.Profile) error); ok {
		r1 = returnFunc(ctx, profile)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProfileRepository_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockProfileRepository_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - profile *user.Profile
func (_e *MockProfileRepository_Expecter) Update(ctx interface{}, profile interface{}) *MockProfileRepository_Update_Call {
	return &MockProfileRepository_Update_Call{Call: _e.mock.On("Update", ctx, profile)}
}

func (_c *MockProfileRepository_Update_Call) Run(run func(ctx context.Context, profile *user.Profile)) *MockProfileRepository_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *user.Profile
		if args[1] != nil {
			arg1 = args[1].(*user.Profile)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProfileRepository_Update_Call) Return(profile1 *user.Profile, err error) *MockProfileRepository_Update_Call {
	_c.Call.Return(profile1, err)
	return _c
}

func (_c *MockProfileRepository_Update_Call) RunAndReturn(run func(ctx context.Context, profile *user.Profile) (*user.Profile, error)) *MockProfileRepository_Update_Call {
	_c.Call.Return(run)
	return _c
}

// Upsert provides a mock function for the type MockProfileRepository
func (_mock *MockProfileRepository) Upsert(ctx context.Context, profile *user.Profile) (*user.Profile, error) {
	ret := _mock.Called(ctx, profile)

	if len(ret) == 0 {
		panic("no return value specified for Upsert")
	}

	var r0 *user.Profile
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.Profile) (*user.Profile, error)); ok {
		return returnFunc(ctx, profile)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.Profile) *user.Profile); ok {
		r0 = returnFunc(ctx, profile)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.Profile)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *user.Profile) error); ok {
		r1 = returnFunc(ctx, profile)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockProfileRepository_Upsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Upsert'
type MockProfileRepository_Upsert_Call struct {
	*mock.Call
}

// Upsert is a helper method to define mock.On call
//   - ctx context.Context
//   - profile *user.Profile
func (_e *MockProfileRepository_Expecter) Upsert(ctx interface{}, profile interface{}) *MockProfileRepository_Upsert_Call {
	return &MockProfileRepository_Upsert_Call{Call: _e.mock.On("Upsert", ctx, profile)}
}

func (_c *MockProfileRepository_Upsert_Call) Run(run func(ctx context.Context, profile *user.Profile)) *MockProfileRepository_Upsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *user.Profile
		if args[1] != nil {
			arg1 = args[1].(*user.Profile)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockProfileRepository_Upsert_Call) Return(profile1 *user.Profile, err error) *MockProfileRepository_Upsert_Call {
	_c.Call.Return(profile1, err)
	return _c
}

func (_c *MockProfileRepository_Upsert_Call) RunAndReturn(run func(ctx context.Context, profile *user.Profile) (*user.Profile, error)) *MockProfileRepository_Upsert_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockTransactionRepository creates a new instance of MockTransactionRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTransactionRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTransactionRepository {
	mock := &MockTransactionRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTransactionRepository is an autogenerated mock type for the TransactionRepository type
type MockTransactionRepository struct {
	mock.Mock
}

type MockTransactionRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTransactionRepository) EXPECT() *MockTransactionRepository_Expecter {
	return &MockTransactionRepository_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockTransactionRepository
func (_mock *MockTransactionRepository) Create(ctx context.Context, tx *transaction.Transaction) (*transaction.Transaction, error) {
	ret := _mock.Called(ctx, tx)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *transaction.Transaction
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *transaction.Transaction) (*transaction.Transaction, error)); ok {
		return returnFunc(ctx, tx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *transaction.Transaction) *transaction.Transaction); ok {
		r0 = returnFunc(ctx, tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*transaction.Transaction)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *transaction.Transaction) error); ok {
		r1 = returnFunc(ctx, tx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTransactionRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockTransactionRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - tx *transaction.Transaction
func (_e *MockTransactionRepository_Expecter) Create(ctx interface{}, tx interface{}) *MockTransactionRepository_Create_Call {
	return &MockTransactionRepository_Create_Call{Call: _e.mock.On("Create", ctx, tx)}
}

func (_c *MockTransactionRepository_Create_Call) Run(run func(ctx context.Context, tx *transaction.Transaction)) *MockTransactionRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *transaction.Transaction
		if args[1] != nil {
			arg1 = args[1].(*transaction.Transaction)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTransactionRepository_Create_Call) Return(transaction1 *transaction.Transaction, err error) *MockTransactionRepository_Create_Call {
	_c.Call.Return(transaction1, err)
	return _c
}

func (_c *MockTransactionRepository_Create_Call) RunAndReturn(run func(ctx context.Context, tx *transaction.Transaction) (*transaction.Transaction, error)) *MockTransactionRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUserRepository creates a new instance of MockUserRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUserRepository {
	mock := &MockUserRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUserRepository is an autogenerated mock type for the UserRepository type
type MockUserRepository struct {
	mock.Mock
}

type MockUserRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUserRepository) EXPECT() *MockUserRepository_Expecter {
	return &MockUserRepository_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) Create(ctx context.Context, user1 *user.User) (*user.User, error) {
	ret := _mock.Called(ctx, user1)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *user.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.User) (*user.User, error)); ok {
		return returnFunc(ctx, user1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.User) *user.User); ok {
		r0 = returnFunc(ctx, user1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *user.User) error); ok {
		r1 = returnFunc(ctx, user1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockUserRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - user1 *user.User
func (_e *MockUserRepository_Expecter) Create(ctx interface{}, user1 interface{}) *MockUserRepository_Create_Call {
	return &MockUserRepository_Create_Call{Call: _e.mock.On("Create", ctx, user1)}
}

func (_c *MockUserRepository_Create_Call) Run(run func(ctx context.Context, user1 *user.User)) *MockUserRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *user.User
		if args[1] != nil {
			arg1 = args[1].(*user.User)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserRepository_Create_Call) Return(user11 *user.User, err error) *MockUserRepository_Create_Call {
	_c.Call.Return(user11, err)
	return _c
}

func (_c *MockUserRepository_Create_Call) RunAndReturn(run func(ctx context.Context, user1 *user.User) (*user.User, error)) *MockUserRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// GetByEmail provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) GetByEmail(ctx context.Context, email string) (*user.User, error) {
	ret := _mock.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for GetByEmail")
	}

	var r0 *user.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*user.User, error)); ok {
		return returnFunc(ctx, email)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *user.User); ok {
		r0 = returnFunc(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, email)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserRepository_GetByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByEmail'
type MockUserRepository_GetByEmail_Call struct {
	*mock.Call
}

// GetByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *MockUserRepository_Expecter) GetByEmail(ctx interface{}, email interface{}) *MockUserRepository_GetByEmail_Call {
	return &MockUserRepository_GetByEmail_Call{Call: _e.mock.On("GetByEmail", ctx, email)}
}

func (_c *MockUserRepository_GetByEmail_Call) Run(run func(ctx context.Context, email string)) *MockUserRepository_GetByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserRepository_GetByEmail_Call) Return(user1 *user.User, err error) *MockUserRepository_GetByEmail_Call {
	_c.Call.Return(user1, err)
	return _c
}

func (_c *MockUserRepository_GetByEmail_Call) RunAndReturn(run func(ctx context.Context, email string) (*user.User, error)) *MockUserRepository_GetByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// GetByID provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) GetByID(ctx context.Context, id string) (*user.User, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 *user.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*user.User, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *user.User); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockUserRepository_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockUserRepository_Expecter) GetByID(ctx interface{}, id interface{}) *MockUserRepository_GetByID_Call {
	return &MockUserRepository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, id)}
}

func (_c *MockUserRepository_GetByID_Call) Run(run func(ctx context.Context, id string)) *MockUserRepository_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserRepository_GetByID_Call) Return(user1 *user.User, err error) *MockUserRepository_GetByID_Call {
	_c.Call.Return(user1, err)
	return _c
}

func (_c *MockUserRepository_GetByID_Call) RunAndReturn(run func(ctx context.Context, id string) (*user.User, error)) *MockUserRepository_GetByID_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUserService creates a new instance of MockUserService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUserService {
	mock := &MockUserService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUserService is an autogenerated mock type for the UserService type
type MockUserService struct {
	mock.Mock
}

type MockUserService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUserService) EXPECT() *MockUserService_Expecter {
	return &MockUserService_Expecter{mock: &_m.Mock}
}

// CreateUser provides a mock function for the type MockUserService
func (_mock *MockUserService) CreateUser(ctx context.Context, req *user.CreateUserRequest) (*user.User, error) {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 *user.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.CreateUserRequest) (*user.User, error)); ok {
		return returnFunc(ctx, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.CreateUserRequest) *user.User); ok {
		r0 = returnFunc(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *user.CreateUserRequest) error); ok {
		r1 = returnFunc(ctx, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserService_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type MockUserService_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - req *user.CreateUserRequest
func (_e *MockUserService_Expecter) CreateUser(ctx interface{}, req interface{}) *MockUserService_CreateUser_Call {
	return &MockUserService_CreateUser_Call{Call: _e.mock.On("CreateUser", ctx, req)}
}

func (_c *MockUserService_CreateUser_Call) Run(run func(ctx context.Context, req *user.CreateUserRequest)) *MockUserService_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *user.CreateUserRequest
		if args[1] != nil {
			arg1 = args[1].(*user.CreateUserRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserService_CreateUser_Call) Return(user1 *user.User, err error) *MockUserService_CreateUser_Call {
	_c.Call.Return(user1, err)
	return _c
}

func (_c *MockUserService_CreateUser_Call) RunAndReturn(run func(ctx context.Context, req *user.CreateUserRequest) (*user.User, error)) *MockUserService_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetProfile provides a mock function for the type MockUserService
func (_mock *MockUserService) GetProfile(ctx context.Context, userID string) (*user.Profile, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetProfile")
	}

	var r0 *user.Profile
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*user.Profile, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *user.Profile); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.Profile)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserService_GetProfile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProfile'
type MockUserService_GetProfile_Call struct {
	*mock.Call
}

// GetProfile is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockUserService_Expecter) GetProfile(ctx interface{}, userID interface{}) *MockUserService_GetProfile_Call {
	return &MockUserService_GetProfile_Call{Call: _e.mock.On("GetProfile", ctx, userID)}
}

func (_c *MockUserService_GetProfile_Call) Run(run func(ctx context.Context, userID string)) *MockUserService_GetProfile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserService_GetProfile_Call) Return(profile *user.Profile, err error) *MockUserService_GetProfile_Call {
	_c.Call.Return(profile, err)
	return _c
}

func (_c *MockUserService_GetProfile_Call) RunAndReturn(run func(ctx context.Context, userID string) (*user.Profile, error)) *MockUserService_GetProfile_Call {
	_c.Call.Return(run)
	return _c
}

// LoginUser provides a mock function for the type MockUserService
func (_mock *MockUserService) LoginUser(ctx context.Context, req *user.LoginUserRequest) (*user.User, error) {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for LoginUser")
	}

	var r0 *user.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.LoginUserRequest) (*user.User, error)); ok {
		return returnFunc(ctx, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *user.LoginUserRequest) *user.User); ok {
		r0 = returnFunc(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *user.LoginUserRequest) error); ok {
		r1 = returnFunc(ctx, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserService_LoginUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoginUser'
type MockUserService_LoginUser_Call struct {
	*mock.Call
}

// LoginUser is a helper method to define mock.On call
//   - ctx context.Context
//   - req *user.LoginUserRequest
func (_e *MockUserService_Expecter) LoginUser(ctx interface{}, req interface{}) *MockUserService_LoginUser_Call {
	return &MockUserService_LoginUser_Call{Call: _e.mock.On("LoginUser", ctx, req)}
}

func (_c *MockUserService_LoginUser_Call) Run(run func(ctx context.Context, req *user.LoginUserRequest)) *MockUserService_LoginUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *user.LoginUserRequest
		if args[1] != nil {
			arg1 = args[1].(*user.LoginUserRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserService_LoginUser_Call) Return(user1 *user.User, err error) *MockUserService_LoginUser_Call {
	_c.Call.Return(user1, err)
	return _c
}

func (_c *MockUserService_LoginUser_Call) RunAndReturn(run func(ctx context.Context, req *user.LoginUserRequest) (*user.User, error)) *MockUserService_LoginUser_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProfile provides a mock function for the type MockUserService
func (_mock *MockUserService) UpdateProfile(ctx context.Context, userID string, req *user.UpdateProfileRequest) (*user.Profile, error) {
	ret := _mock.Called(ctx, userID, req)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProfile")
	}

	var r0 *user.Profile
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *user.UpdateProfileRequest) (*user.Profile, error)); ok {
		return returnFunc(ctx, userID, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *user.UpdateProfileRequest) *user.Profile); ok {
		r0 = returnFunc(ctx, userID, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*user.Profile)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, *user.UpdateProfileRequest) error); ok {
		r1 = returnFunc(ctx, userID, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserService_UpdateProfile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProfile'
type MockUserService_UpdateProfile_Call struct {
	*mock.Call
}

// UpdateProfile is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - req *user.UpdateProfileRequest
func (_e *MockUserService_Expecter) UpdateProfile(ctx interface{}, userID interface{}, req interface{}) *MockUserService_UpdateProfile_Call {
	return &MockUserService_UpdateProfile_Call{Call: _e.mock.On("UpdateProfile", ctx, userID, req)}
}

func (_c *MockUserService_UpdateProfile_Call) Run(run func(ctx context.Context, userID string, req *user.UpdateProfileRequest)) *MockUserService_UpdateProfile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 *user.UpdateProfileRequest
		if args[2] != nil {
			arg2 = args[2].(*user.UpdateProfileRequest)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockUserService_UpdateProfile_Call) Return(profile *user.Profile, err error) *MockUserService_UpdateProfile_Call {
	_c.Call.Return(profile, err)
	return _c
}

func (_c *MockUserService_UpdateProfile_Call) RunAndReturn(run func(ctx context.Context, userID string, req *user.UpdateProfileRequest) (*user.Profile, error)) *MockUserService_UpdateProfile_Call {
	_c.Call.Return(run)
	return _c
}
